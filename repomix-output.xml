This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  rules/
    cursor-rule-location.mdc
    enforce-shadcn-ui.mdc
    lucide-icons.mdc
src/
  main/
    index.ts
  preload/
    index.d.ts
    index.ts
  renderer/
    components/
      AssetGrid.css
      AssetGrid.tsx
      AssetPreview.css
      AssetPreview.tsx
      FilePicker.tsx
      FileTreeSidebar.tsx
    src/
      assets/
        base.css
        main.css
      components/
        ui/
          alert.tsx
          button.tsx
          collapsible.tsx
          input.tsx
          scroll-area.tsx
          separator.tsx
          sheet.tsx
          sidebar.tsx
          skeleton.tsx
          toast.tsx
          toaster.tsx
          tooltip.tsx
        Versions.tsx
      lib/
        hooks/
          use-mobile.tsx
          use-toast.ts
        utils.ts
      App.tsx
      env.d.ts
      main.tsx
    index.html
.cursor-updates
.editorconfig
.gitignore
.npmrc
.prettierignore
.prettierrc.yaml
CLAUDE.md
components.json
dev-app-update.yml
electron-builder.yml
electron.vite.config.ts
eslint.config.mjs
package.json
postcss.config.js
README.md
tailwind.config.js
tasks.md
tsconfig.json
tsconfig.node.json
tsconfig.web.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/cursor-rule-location.mdc">
---
description: 
globs: 
alwaysApply: true
---
---
description: 
globs: 
alwaysApply: true
---
---
description: Cursor Rules Location
globs: *.mdc
---
# Cursor Rules Location

Rules for placing and organizing Cursor rule files in the repository.

<rule>
name: cursor_rules_location
description: Standards for placing Cursor rule files in the correct directory
filters:
  # Match any .mdc files
  - type: file_extension
    pattern: "\\.mdc$"
  # Match files that look like Cursor rules
  - type: content
    pattern: "(?s)<rule>.*?</rule>"
  # Match file creation events
  - type: event
    pattern: "file_create"

actions:
  - type: reject
    conditions:
      - pattern: "^(?!\\.\\/\\.cursor\\/rules\\/.*\\.mdc$)"
        message: "Cursor rule files (.mdc) must be placed in the .cursor/rules directory"

  - type: suggest
    message: |
      When creating Cursor rules:

      1. Always place rule files in PROJECT_ROOT/.cursor/rules/:
         ```
         .cursor/rules/
         ├── your-rule-name.mdc
         ├── another-rule.mdc
         └── ...
         ```

      2. Follow the naming convention:
         - Use kebab-case for filenames
         - Always use .mdc extension
         - Make names descriptive of the rule's purpose

      3. Directory structure:
         ```
         PROJECT_ROOT/
         ├── .cursor/
         │   └── rules/
         │       ├── your-rule-name.mdc
         │       └── ...
         └── ...
         ```

      4. Never place rule files:
         - In the project root
         - In subdirectories outside .cursor/rules
         - In any other location

examples:
  - input: |
      # Bad: Rule file in wrong location
      rules/my-rule.mdc
      my-rule.mdc
      .rules/my-rule.mdc

      # Good: Rule file in correct location
      .cursor/rules/my-rule.mdc
    output: "Correctly placed Cursor rule file"

metadata:
  priority: high
  version: 1.0
</rule>
</file>

<file path=".cursor/rules/enforce-shadcn-ui.mdc">
---
description: 
globs: src/renderer/**/*.tsx
alwaysApply: false
---
# ShadCN UI Enforcement Rule

Ensures that [ShadCN UI](mdc:https:/ui.shadcn.com) is used for components and that the new CLI is used when generating them.

<rule>
name: enforce_shadcn_ui
description: Rejects imports from common alternative UI libraries and suggests using ShadCN UI with its CLI.
filters:
  # Match TSX and JSX files
  - type: file_extension
    pattern: "\\.[jt]sx?$"
  # Match import statements from disallowed UI libraries
  # This pattern looks for imports from a list of libraries.
  - type: content
    pattern: "import\\s+.*?\\s+from\\s+['"](mdc:?:@mui/material|@material-ui/core|antd|react-bootstrap|semantic-ui-react|@chakra-ui/react|@nextui-org/react|rsuite|primereact|@headlessui/react|@radix-ui/themes|@blueprintjs/core)['"];"

actions:
  - type: reject
    message: |
      Please use ShadCN UI for components instead of the imported UI library.
      ShadCN UI provides a set of beautifully designed, accessible, and customizable components.

      To initialize ShadCN UI in your project (if you haven't already):
      ```bash
      npx shadcn-ui@latest init
      ```

      To add ShadCN UI components to your project, use the CLI:
      ```bash
      npx shadcn-ui@latest add [component-name]
      ```
      For example, to add a button:
      ```bash
      npx shadcn-ui@latest add button
      ```
      Components are then typically imported from your local components directory (e.g., `@/components/ui/button`), which this rule allows.

examples:
  - input: |
      // Bad: Importing from Material UI
      import Button from '@mui/material/Button';

      function MyComponent() {
        return <Button>Click Me</Button>;
      }
    output: "Reject: Use ShadCN UI instead. The message will guide on using ShadCN CLI."

  - input: |
      // Good: Using a ShadCN UI component (typically imported like this)
      import { Button } from "@/components/ui/button"; // This import pattern is NOT targeted by the rule's reject pattern.

      function MyComponent() {
        return <Button variant="outline">Submit</Button>;
      }
    output: "Pass: This code does not import from the disallowed UI libraries."

metadata:
  priority: high
  version: 1.0
  tags: ["components", "ui-library", "shadcn", "best-practice", "cli"]
</rule>
</file>

<file path=".cursor/rules/lucide-icons.mdc">
---
description: 
globs: 
alwaysApply: true
---
# Lucide Icons Usage Rule

Ensures that `lucide-react-native` is used for icons instead of older vector icon libraries.

<rule>
name: enforce_lucide_icons
description: Rejects imports from react-native-vector-icons or @expo/vector-icons. Suggests using lucide-react-native instead.
filters:
  # Match files where vector icons might be imported
  - type: file_extension
    pattern: "\.[jt]sx?$"
  # Match import statements from the disallowed libraries
  - type: content
    pattern: "import\s+.*?\s+from\s+['"](?:react-native-vector-icons(?:/.*)?|@expo/vector-icons)['"];"

actions:
  - type: reject
    message: |
      Please use `lucide-react-native` for icons instead of `react-native-vector-icons` or `@expo/vector-icons`.

      Example:
      ```typescript
      // Replace this:
      // import { Ionicons } from '@expo/vector-icons';
      // <Ionicons name="md-checkmark-circle" size={32} color="green" />

      // With this:
      import { CheckCircle } from 'lucide-react-native';
      // <CheckCircle size={32} color="green" />
      ```

examples:
  - input: |
      // Bad: Importing from @expo/vector-icons
      import { FontAwesome } from '@expo/vector-icons';
      import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';

      function MyComponent() {
        return <FontAwesome name="rocket" size={30} color="#900" />;
      }
    output: "Reject: Use lucide-react-native instead."

  - input: |
      // Good: Importing from lucide-react-native
      import { Rocket } from 'lucide-react-native';

      function MyComponent() {
        return <Rocket size={30} color="#900" />;
      }
    output: "Pass: Correct icon library used."

metadata:
  priority: medium
  version: 1.0
  tags: ["icons", "dependencies", "best-practice", "lucide"]
</rule>
</file>

<file path="src/renderer/components/FilePicker.tsx">
import React from 'react'
import { FolderOpen } from 'lucide-react'

interface FolderPickerProps {
  onFolderSelect: (folderPath: string) => void
  onError: (message: string) => void
}

const FolderPicker: React.FC<FolderPickerProps> = ({ onFolderSelect, onError }) => {
  // Handle folder selection dialog
  const handleSelectFolder = async (): Promise<void> => {
    try {
      const result = await window.api.selectFolder()
      console.log('Folder selection result:', result)

      if (result.success && result.folderPath) {
        onFolderSelect(result.folderPath)
      } else {
        onError(result.message || 'Failed to select folder')
      }
    } catch (error) {
      console.error('Error selecting folder:', error)
      onError('An error occurred while selecting a folder')
    }
  }

  return (
    <button
      onClick={handleSelectFolder}
      className="browse-folder-button"
      style={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        padding: '8px 12px',
        backgroundColor: '#f3f4f6',
        border: '1px solid #e5e7eb',
        borderRadius: '4px',
        cursor: 'pointer',
        margin: '8px auto',
        width: 'calc(100% - 16px)',
        color: '#4f46e5',
        fontWeight: 500,
        fontSize: '0.875rem'
      }}
    >
      <FolderOpen style={{ height: '1rem', width: '1rem', marginRight: '0.5rem' }} />
      Browse for folder...
    </button>
  )
}

export default FolderPicker
</file>

<file path="src/renderer/src/assets/main.css">
@import './base.css';
</file>

<file path="src/renderer/src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/renderer/src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="src/renderer/src/components/ui/collapsible.tsx">
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
</file>

<file path="src/renderer/src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="src/renderer/src/components/ui/scroll-area.tsx">
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</file>

<file path="src/renderer/src/components/ui/separator.tsx">
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src/renderer/src/components/ui/sidebar.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/lib/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContextProps>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <SheetHeader className="sr-only">
              <SheetTitle>Sidebar</SheetTitle>
              <SheetDescription>Displays the mobile sidebar.</SheetDescription>
            </SheetHeader>
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex w-full flex-1 flex-col bg-background",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="src/renderer/src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="src/renderer/src/components/ui/toast.tsx">
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
</file>

<file path="src/renderer/src/components/ui/toaster.tsx">
"use client"

import { useToast } from "@/lib/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
</file>

<file path="src/renderer/src/components/ui/tooltip.tsx">
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src/renderer/src/components/Versions.tsx">
import { useState } from 'react'

function Versions(): React.JSX.Element {
  const [versions] = useState(window.electron.process.versions)

  return (
    <ul className="versions">
      <li className="electron-version">Electron v{versions.electron}</li>
      <li className="chrome-version">Chromium v{versions.chrome}</li>
      <li className="node-version">Node v{versions.node}</li>
    </ul>
  )
}

export default Versions
</file>

<file path="src/renderer/src/lib/hooks/use-mobile.tsx">
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
</file>

<file path="src/renderer/src/lib/hooks/use-toast.ts">
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="src/renderer/src/lib/utils.ts">
import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/renderer/src/env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="src/renderer/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App'
import './assets/main.css'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
)
</file>

<file path="src/renderer/index.html">
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Electron</title>
    <!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP -->
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:"
    />
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path=".editorconfig">
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true
</file>

<file path=".gitignore">
node_modules
dist
out
.DS_Store
.eslintcache
*.log*
</file>

<file path=".npmrc">
shamefully-hoist=true
node-linker=hoisted
public-hoist-pattern=*
ELECTRON_MIRROR=https://npmmirror.com/mirrors/electron/
</file>

<file path=".prettierignore">
out
dist
pnpm-lock.yaml
LICENSE.md
tsconfig.json
tsconfig.*.json
</file>

<file path=".prettierrc.yaml">
singleQuote: true
semi: false
printWidth: 100
trailingComma: none
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Common Commands

### Development

```bash
# Install dependencies
npm install

# Start development mode with hot reload
npm run dev

# Format code with Prettier
npm run format

# Run ESLint
npm run lint

# Run type checking for node and web separately
npm run typecheck:node
npm run typecheck:web

# Run all type checking
npm run typecheck

# Preview the application in production mode
npm run start
```

### Building

```bash
# Build for current platform
npm run build

# Build without packaging
npm run build:unpack

# Build for specific platforms
npm run build:win    # Windows
npm run build:mac    # macOS
npm run build:linux  # Linux
```

## Project Architecture

Asset Viewer is an Electron application built with React and TypeScript. It allows game developers to view and manage 2D sprite assets, with features like folder navigation, asset previews, and animation sequence detection.

### Key Components

1. **Main Process (Electron)**
   - `src/main/index.ts`: Initializes the Electron app, sets up IPC communication, and handles file system operations.
   - Registers a custom `asset://` protocol for secure local file access.
   - Implements IPC handlers for folder navigation and asset detection.

2. **Renderer Process (React)**
   - `src/renderer/src/App.tsx`: Main React component that orchestrates the overall UI layout.
   - `src/renderer/components/FileTreeSidebar.tsx`: Displays a collapsible folder tree for navigation.
   - `src/renderer/components/AssetGrid.tsx`: Shows a grid of available sprite assets in the selected folder.
   - `src/renderer/components/AssetPreview.tsx`: Displays the selected asset with preview features (zoom, transparency).

3. **IPC Communication**
   - Communication between the main and renderer processes happens via IPC channels:
     - `select-folder`: Opens a system folder picker dialog
     - `navigate-to-folder`: Scans a directory and returns file structure
     - `get-animation-frames`: Detects animation frame sequences

4. **UI Architecture**
   - Uses a combination of custom components and UI primitives from the Radix UI library.
   - Styled with Tailwind CSS.
   - Components include modular sidebar, asset grid, and preview areas.

### Data Flow

1. User selects a folder through the sidebar
2. Main process scans the folder and returns file structure
3. Renderer displays assets in the grid component
4. User selects an asset from the grid
5. Selected asset is displayed in the preview component
6. If animation sequence is detected, playback controls are enabled

## Feature Implementation Status

The application is implementing features based on user stories in `tasks.md`. Currently implemented features include:

- File system navigation with a folder tree
- Asset grid with sorting options
- Transparency rendering in the preview component
- Background customization for transparency
- Asset preview with zoom capabilities
- Detection of animation sequences

Features in progress include:

- Mouse wheel zoom and pan controls
- Animation playback for sprite sheets and frame-by-frame animations
- Asset metadata display
- Thumbnail generation and caching

## Code Patterns

- **Component Composition**: UI is built from composable React components
- **State Management**: Uses React's built-in state hooks
- **IPC Communication**: Follows Electron's IPC pattern for main/renderer process communication
- **File System Operations**: File operations are performed in the main process for security
- **Error Handling**: Uses try/catch blocks with user-friendly error messages

When making changes to the codebase, follow these patterns and maintain consistency with the existing code style.
</file>

<file path="dev-app-update.yml">
provider: generic
url: https://example.com/auto-updates
updaterCacheDirName: asset-viewer-updater
</file>

<file path="electron-builder.yml">
appId: com.electron.app
productName: asset-viewer
directories:
  buildResources: build
files:
  - '!**/.vscode/*'
  - '!src/*'
  - '!electron.vite.config.{js,ts,mjs,cjs}'
  - '!{.eslintcache,eslint.config.mjs,.prettierignore,.prettierrc.yaml,dev-app-update.yml,CHANGELOG.md,README.md}'
  - '!{.env,.env.*,.npmrc,pnpm-lock.yaml}'
  - '!{tsconfig.json,tsconfig.node.json,tsconfig.web.json}'
asarUnpack:
  - resources/**
win:
  executableName: asset-viewer
nsis:
  artifactName: ${name}-${version}-setup.${ext}
  shortcutName: ${productName}
  uninstallDisplayName: ${productName}
  createDesktopShortcut: always
mac:
  entitlementsInherit: build/entitlements.mac.plist
  extendInfo:
    - NSCameraUsageDescription: Application requests access to the device's camera.
    - NSMicrophoneUsageDescription: Application requests access to the device's microphone.
    - NSDocumentsFolderUsageDescription: Application requests access to the user's Documents folder.
    - NSDownloadsFolderUsageDescription: Application requests access to the user's Downloads folder.
  notarize: false
dmg:
  artifactName: ${name}-${version}.${ext}
linux:
  target:
    - AppImage
    - snap
    - deb
  maintainer: electronjs.org
  category: Utility
appImage:
  artifactName: ${name}-${version}.${ext}
npmRebuild: false
publish:
  provider: generic
  url: https://example.com/auto-updates
</file>

<file path="eslint.config.mjs">
import tseslint from '@electron-toolkit/eslint-config-ts'
import eslintConfigPrettier from '@electron-toolkit/eslint-config-prettier'
import eslintPluginReact from 'eslint-plugin-react'
import eslintPluginReactHooks from 'eslint-plugin-react-hooks'
import eslintPluginReactRefresh from 'eslint-plugin-react-refresh'

export default tseslint.config(
  { ignores: ['**/node_modules', '**/dist', '**/out'] },
  tseslint.configs.recommended,
  eslintPluginReact.configs.flat.recommended,
  eslintPluginReact.configs.flat['jsx-runtime'],
  {
    settings: {
      react: {
        version: 'detect'
      }
    }
  },
  {
    files: ['**/*.{ts,tsx}'],
    plugins: {
      'react-hooks': eslintPluginReactHooks,
      'react-refresh': eslintPluginReactRefresh
    },
    rules: {
      ...eslintPluginReactHooks.configs.recommended.rules,
      ...eslintPluginReactRefresh.configs.vite.rules
    }
  },
  eslintConfigPrettier
)
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [{ "path": "./tsconfig.node.json" }, { "path": "./tsconfig.web.json" }],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
     "@/*": [
        "./src/renderer/src/*"
      ]
    }
  }
}
</file>

<file path="tsconfig.node.json">
{
  "extends": "@electron-toolkit/tsconfig/tsconfig.node.json",
  "include": ["electron.vite.config.*", "src/main/**/*", "src/preload/**/*"],
  "compilerOptions": {
    "composite": true,
    "types": ["electron-vite/node"]
  }
}
</file>

<file path="src/renderer/components/AssetGrid.css">
.asset-grid-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  overflow: hidden;
}

.asset-grid-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  border-bottom: 1px solid var(--border-color, #e2e8f0);
  background-color: var(--background-color, #f8fafc);
}

.asset-count {
  font-size: 0.875rem;
  color: var(--muted-foreground, #64748b);
}

.sort-controls {
  display: flex;
  gap: 0.5rem;
}

.sort-button {
  background: transparent;
  border: none;
  padding: 0.25rem 0.5rem;
  font-size: 0.75rem;
  border-radius: 0.25rem;
  cursor: pointer;
  color: var(--muted-foreground, #64748b);
}

.sort-button:hover {
  background-color: var(--hover-color, #f1f5f9);
}

.sort-button.active {
  font-weight: 600;
  color: var(--foreground, #0f172a);
}

.asset-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 1rem;
  padding: 1rem;
  overflow-y: auto;
  flex: 1;
}

.asset-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  padding: 0.5rem;
  border-radius: 0.25rem;
  border: 2px solid transparent;
  transition: all 0.2s ease;
}

.asset-item:hover {
  background-color: var(--hover-color, #f1f5f9);
}

.asset-item.selected {
  border-color: var(--primary-color, #3b82f6);
  background-color: var(--selected-bg, #eff6ff);
}

.asset-thumbnail {
  width: 100%;
  aspect-ratio: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--thumbnail-bg, #e2e8f0);
  border-radius: 0.25rem;
  margin-bottom: 0.5rem;
  overflow: hidden;
  position: relative;
}

.asset-icon,
.asset-icon-fallback {
  width: 40%;
  height: 40%;
  color: var(--muted-foreground, #64748b);
}

.asset-image {
  width: 100%;
  height: 100%;
  object-fit: contain;
  object-position: center;
}

.asset-name {
  font-size: 0.75rem;
  text-align: center;
  width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.asset-grid-loading,
.asset-grid-error,
.asset-grid-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  font-size: 0.875rem;
  color: var(--muted-foreground, #64748b);
}

.asset-grid-loading {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.asset-grid-error {
  color: var(--error-color, #ef4444);
}

.asset-grid-header {
  padding: 1rem;
  border-bottom: 1px solid var(--border-color, #e2e8f0);
  display: flex;
  align-items: center;
}

.animate-spin {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
</file>

<file path="src/renderer/src/assets/base.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 47.4% 11.2%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 47.4% 11.2%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 100% 50%;
    --destructive-foreground: 210 40% 98%;
    --ring: 215 20.2% 65.1%;
    --radius: 0.5rem;
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }

  .dark {
    --background: 224 71% 4%;
    --foreground: 213 31% 91%;
    --muted: 223 47% 11%;
    --muted-foreground: 215.4 16.3% 56.9%;
    --accent: 216 34% 17%;
    --accent-foreground: 210 40% 98%;
    --popover: 224 71% 4%;
    --popover-foreground: 215 20.2% 65.1%;
    --border: 216 34% 17%;
    --input: 216 34% 17%;
    --card: 224 71% 4%;
    --card-foreground: 213 31% 91%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 1.2%;
    --secondary: 222.2 47.4% 11.2%;
    --secondary-foreground: 210 40% 98%;
    --destructive: 0 63% 31%;
    --destructive-foreground: 210 40% 98%;
    --ring: 216 34% 17%;
    --radius: 0.5rem;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply font-sans antialiased bg-background text-foreground;
  }
}



@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src/renderer/src/components/ui/sheet.tsx">
'use client'

import * as React from 'react'
import * as SheetPrimitive from '@radix-ui/react-dialog'
import { cva, type VariantProps } from 'class-variance-authority'
import { X } from 'lucide-react'

import { cn } from '@/lib/utils'

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out',
  {
    variants: {
      side: {
        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
        bottom:
          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
        right:
          'inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm'
      }
    },
    defaultVariants: {
      side: 'right'
    }
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = 'right', className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content ref={ref} className={cn(sheetVariants({ side }), className)} {...props}>
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
      {children}
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn('flex flex-col space-y-2 text-center sm:text-left', className)} {...props} />
)
SheetHeader.displayName = 'SheetHeader'

const SheetFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', className)}
    {...props}
  />
)
SheetFooter.displayName = 'SheetFooter'

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold text-foreground', className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description ref={ref} className={cn('text-sm', className)} {...props} />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription
}
</file>

<file path="components.json">
{
  "style": "new-york",
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/renderer/src/assets/base.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "rsc": false,
  "aliases": {
    "utils": "@/renderer/src/lib/utils",
    "components": "@/renderer/src/components",
    "lib": "@/renderer/src/lib",
    "hooks": "@/renderer/src/lib/hooks",
    "ui": "@/renderer/src/components/ui"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="electron.vite.config.ts">
import { resolve } from 'path'
import { defineConfig, externalizeDepsPlugin } from 'electron-vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  main: {
    plugins: [externalizeDepsPlugin()]
  },
  preload: {
    plugins: [externalizeDepsPlugin()]
  },
  renderer: {
    resolve: {
      alias: {
        '@renderer': resolve('src/renderer/src'),
        '@': resolve('src/renderer/src')
      }
    },
    plugins: [react()]
  }
})
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
    darkMode: ['class'],
    content: ['./src/renderer/src/**/*.{js,ts,jsx,tsx}'],
  theme: {
  	container: {
  		center: true,
  		padding: '2rem',
  		screens: {
  			'2xl': '1400px'
  		}
  	},
  	extend: {
  		colors: {
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			sidebar: {
  				DEFAULT: 'hsl(var(--sidebar-background))',
  				foreground: 'hsl(var(--sidebar-foreground))',
  				primary: 'hsl(var(--sidebar-primary))',
  				'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
  				accent: 'hsl(var(--sidebar-accent))',
  				'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
  				border: 'hsl(var(--sidebar-border))',
  				ring: 'hsl(var(--sidebar-ring))'
  			}
  		},
  		borderRadius: {
  			lg: '`var(--radius)`',
  			md: '`calc(var(--radius) - 2px)`',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			}
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out'
  		}
  	}
  },
  plugins: [require('tailwindcss-animate')]
}
</file>

<file path="tsconfig.web.json">
{
  "extends": "@electron-toolkit/tsconfig/tsconfig.web.json",
  "include": [
    "src/renderer/src/env.d.ts",
    "src/renderer/src/**/*",
    "src/renderer/src/**/*.tsx",
    "src/renderer/components/**/*.tsx",
    "src/preload/*.d.ts"
  ],
  "compilerOptions": {
    "composite": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/renderer/src/*"],
      "@renderer/*": [
        "src/renderer/src/*"
      ]
    }
  }
}
</file>

<file path="src/renderer/components/AssetPreview.css">
.asset-preview {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  width: 100%;
  position: relative;
  overflow: hidden;
}

.asset-preview .empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  width: 100%;
  color: #666;
  font-size: 1.2rem;
  text-align: center;
  gap: 0.5rem;
}

.asset-preview .loading-indicator,
.asset-preview .error-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 10px 20px;
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  border-radius: 4px;
  z-index: 10;
}

.asset-preview .error-message {
  background-color: rgba(220, 53, 69, 0.9);
}

/* Controls panel */
.controls-panel {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 8px 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  z-index: 20;
  font-size: 12px;
}

/* Animation controls */
.animation-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 0 10px;
}

/* Sprite Sheet Configuration */
.sprite-sheet-config {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-right: 10px;
}

.config-title {
  font-size: 11px;
  color: rgba(255, 255, 255, 0.8);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.config-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.sprite-sheet-config label {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 11px;
}

.sprite-sheet-config input[type='number'] {
  width: 40px;
  height: 22px;
  padding: 0 4px;
  background-color: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 3px;
  color: white;
  text-align: center;
}

.sprite-sheet-config .apply-button {
  background-color: rgba(0, 123, 255, 0.7);
  color: white;
  border: none;
  border-radius: 3px;
  padding: 2px 8px;
  font-size: 11px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.sprite-sheet-config .apply-button:hover {
  background-color: rgba(0, 123, 255, 0.9);
}

.icon-button {
  background: none;
  border: 1px solid rgba(255, 255, 255, 0.3);
  color: white;
  border-radius: 4px;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
}

.icon-button:hover {
  background-color: rgba(255, 255, 255, 0.2);
}

.icon-button:active {
  background-color: rgba(255, 255, 255, 0.3);
}

.speed-control {
  display: flex;
  align-items: center;
  gap: 4px;
  margin-left: 10px;
}

.speed-control input[type='range'] {
  width: 80px;
  height: 4px;
}

.frame-counter {
  margin-left: 10px;
  font-size: 11px;
  color: rgba(255, 255, 255, 0.8);
}

/* Zoom information display */
.zoom-info {
  display: flex;
  gap: 8px;
}

.sprite-sheet-toggle {
  background-color: rgba(0, 123, 255, 0.7);
  color: white;
  border: none;
  border-radius: 3px;
  padding: 2px 8px;
  font-size: 11px;
  cursor: pointer;
  transition: background-color 0.2s;
  margin-left: 8px;
}

.sprite-sheet-toggle:hover {
  background-color: rgba(0, 123, 255, 0.9);
}

/* Background options */
.background-options {
  display: flex;
  align-items: center;
  gap: 8px;
}

.background-buttons {
  display: flex;
  gap: 4px;
}

.bg-option {
  width: 24px;
  height: 24px;
  border: 1px solid #888;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.bg-option:hover {
  transform: scale(1.1);
}

.bg-option.active {
  border: 2px solid #fff;
  transform: scale(1.05);
}

.image-container {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  /* Background pattern is now set via inline styles */
  overflow: auto; /* Allow scrolling when image is larger than container */
}

.preview-image {
  display: block;
  /* Remove max-width and max-height constraints to show actual size */
  /* max-width: 100%;
  max-height: 100%; */
  object-fit: contain;
  /* Allow the checkered background to show through transparent parts */
  image-rendering: pixelated; /* Keeps pixel art crisp when zoomed */
}
</file>

<file path="src/preload/index.d.ts">
import { ElectronAPI } from '@electron-toolkit/preload'

interface TreeNode {
  id: string
  name: string
  type: 'folder' | 'file'
  children?: TreeNode[]
  isAssetFolder?: boolean
}

// Define a recursive type for file tree items
interface FileTreeItem {
  id: string
  name: string
  type: 'folder' | 'file'
  path?: string
  isAssetFolder?: boolean
  children?: FileTreeItem[]
}

interface API {
  navigateToFolder: (folderPath: string) => Promise<{
    success: boolean
    folderPath?: string
    folderName?: string
    message?: string
    children?: FileTreeItem[]
  }>
  selectFolder: () => Promise<{
    success: boolean
    folderPath?: string
    message?: string
  }>
  getAnimationFrames: (
    folderPath: string,
    baseName: string,
    extension: string
  ) => Promise<{
    success: boolean
    frames: Array<{ path: string; name: string }>
    message?: string
  }>
  showAssetContextMenu: (assetPath: string) => Promise<void>
  copyAssetPath: (assetPath: string) => Promise<void>
  copyAssetFile: (assetPath: string) => Promise<void>
  showAssetInFolder: (assetPath: string) => Promise<void>
}

declare global {
  interface Window {
    electron: ElectronAPI
    api: API
  }
}
</file>

<file path="src/preload/index.ts">
import { contextBridge, ipcRenderer } from 'electron'
import { electronAPI } from '@electron-toolkit/preload'

// Custom APIs for renderer
const api = {
  navigateToFolder: (folderPath: string) => ipcRenderer.invoke('navigate-to-folder', folderPath),
  selectFolder: () => ipcRenderer.invoke('select-folder'),
  getAnimationFrames: (folderPath: string, baseName: string, extension: string) =>
    ipcRenderer.invoke('get-animation-frames', folderPath, baseName, extension),
  showAssetContextMenu: (assetPath: string) =>
    ipcRenderer.invoke('show-asset-context-menu', assetPath),
  copyAssetPath: (assetPath: string) => ipcRenderer.invoke('copy-asset-path', assetPath),
  copyAssetFile: (assetPath: string) => ipcRenderer.invoke('copy-asset-file', assetPath),
  showAssetInFolder: (assetPath: string) => ipcRenderer.invoke('show-asset-in-folder', assetPath)
}

// Use `contextBridge` APIs to expose Electron APIs to
// renderer only if context isolation is enabled, otherwise
// just add to the DOM global.
if (process.contextIsolated) {
  try {
    contextBridge.exposeInMainWorld('electron', electronAPI)
    contextBridge.exposeInMainWorld('api', api)
  } catch (error) {
    console.error(error)
  }
} else {
  // @ts-ignore (define in dts)
  window.electron = electronAPI
  // @ts-ignore (define in dts)
  window.api = api
}
</file>

<file path="package.json">
{
  "name": "asset-viewer",
  "version": "1.0.0",
  "description": "An Electron application with React and TypeScript",
  "main": "./out/main/index.js",
  "author": "example.com",
  "homepage": "https://electron-vite.org",
  "scripts": {
    "format": "prettier --write .",
    "lint": "eslint --cache .",
    "typecheck:node": "tsc --noEmit -p tsconfig.node.json --composite false",
    "typecheck:web": "tsc --noEmit -p tsconfig.web.json --composite false",
    "typecheck": "npm run typecheck:node && npm run typecheck:web",
    "start": "electron-vite preview",
    "dev": "electron-vite dev",
    "build": "npm run typecheck && electron-vite build",
    "postinstall": "electron-builder install-app-deps",
    "build:unpack": "npm run build && electron-builder --dir",
    "build:win": "npm run build && electron-builder --win",
    "build:mac": "electron-vite build && electron-builder --mac",
    "build:linux": "electron-vite build && electron-builder --linux"
  },
  "dependencies": {
    "@electron-toolkit/preload": "^3.0.1",
    "@electron-toolkit/utils": "^4.0.0",
    "@radix-ui/react-collapsible": "^1.1.10",
    "@radix-ui/react-dialog": "^1.1.13",
    "@radix-ui/react-scroll-area": "^1.2.8",
    "@radix-ui/react-separator": "^1.1.6",
    "@radix-ui/react-slot": "^1.2.2",
    "@radix-ui/react-toast": "^1.2.13",
    "@radix-ui/react-tooltip": "^1.2.6",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "electron-updater": "^6.3.9",
    "lucide-react": "^0.509.0",
    "tailwind-merge": "^3.2.0",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@electron-toolkit/eslint-config-prettier": "^3.0.0",
    "@electron-toolkit/eslint-config-ts": "^3.0.0",
    "@electron-toolkit/tsconfig": "^1.0.1",
    "@types/node": "^22.14.1",
    "@types/react": "^19.1.1",
    "@types/react-dom": "^19.1.2",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.21",
    "electron": "^35.1.5",
    "electron-builder": "^25.1.8",
    "electron-vite": "^3.1.0",
    "eslint": "^9.24.0",
    "eslint-plugin-react": "^7.37.5",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "postcss": "^8.5.3",
    "prettier": "^3.5.3",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "tailwindcss": "3.4.14",
    "typescript": "^5.8.3",
    "vite": "^6.2.6"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "electron"
    ]
  }
}
</file>

<file path="README.md">
# 2D Asset Viewer

A lightweight desktop application for game developers to view, organize, and preview 2D sprite assets.

## Demo

![Demo](./assets/demo.mp4)

_A video demonstration of Asset Viewer in action. Replace this with your actual demo recording._

## What It Does

Asset Viewer is an Electron-based application that helps game developers manage their 2D sprite assets. Key features include:

- **File System Navigation:** Browse your computer's folders to locate sprite assets
- **Asset Preview:** View sprite images with transparency support and background customization
- **Animation Detection:** Automatically detect frame-based animation sequences
- **Sprite Sheet Support:** View sprite sheets with configurable rows and columns
- **Animation Playback:** Play, pause, and control animation sequences
- **Asset Grid:** View all assets in a folder with sorting options
- **Drag and Drop:** Quickly navigate to folders by drag-and-drop

This tool is designed to simplify the workflow of game developers and artists working with 2D sprites by providing a dedicated viewer tailored to their needs.

## Getting Started

### Prerequisites

- [Node.js](https://nodejs.org/) (v16 or newer)
- npm or pnpm

### Installation

```bash
# Clone the repository
git clone https://github.com/yourusername/asset-viewer.git
cd asset-viewer

# Install dependencies with npm
npm install

# Or with pnpm (recommended)
pnpm install
```

### Available Commands

The project uses pnpm as its primary package manager, but npm commands will work too. Here's a complete list of available commands:

```bash
# Development
pnpm dev                # Start the app in development mode with hot reload
pnpm start              # Preview the built app in production mode

# Code Quality
pnpm format             # Format all files with Prettier
pnpm lint               # Run ESLint
pnpm typecheck:node     # Run TypeScript check for Node.js code
pnpm typecheck:web      # Run TypeScript check for web code
pnpm typecheck          # Run all TypeScript checks

# Building
pnpm build              # Build the app for the current platform
pnpm build:unpack       # Build without packaging into an installer
pnpm build:win          # Build for Windows
pnpm build:mac          # Build for macOS
pnpm build:linux        # Build for Linux
```

If you prefer npm, just replace `pnpm` with `npm run` in the commands above.

### Running the Application

```bash
# Start in development mode with hot reload
pnpm dev
```

The development server will start and the application window should open automatically.

### Building for Distribution

```bash
# For Windows
pnpm build:win

# For macOS
pnpm build:mac

# For Linux
pnpm build:linux
```

The built application will be available in the `dist` directory.

## Usage

1. Launch the application
2. Click the folder icon in the sidebar to select a folder containing sprite assets
3. Browse the folder structure in the sidebar
4. Click on any image to preview it in the main pane
5. Use the controls at the top of the preview pane to adjust background, zoom, or play animations
6. Sort assets using the controls above the asset grid

## Development Status

**Important Note:** This application was built very quickly with the assistance of AI tools. While it's functional for basic use cases, it has not undergone extensive testing or refinement. There are likely edge cases and bugs that haven't been addressed.

The code is provided as-is, and I'm unlikely to fix any bugs that are reported unless they affect my own workflow directly. Feel free to fork the repository and make improvements as needed.

## Project Structure

```
asset-viewer/
├── src/
│   ├── main/             # Electron main process
│   ├── preload/          # Preload scripts
│   └── renderer/         # React frontend
│       ├── components/   # React components
│       └── src/          # App logic and UI
├── resources/            # App resources
└── build/                # Build configuration
```

## System Requirements

- **Windows:** Windows 10 or newer
- **macOS:** macOS 10.14 (Mojave) or newer
- **Linux:** Ubuntu 18.04 or newer, or equivalent

## Technologies Used

- [Electron](https://www.electronjs.org/)
- [React](https://reactjs.org/)
- [TypeScript](https://www.typescriptlang.org/)
- [Tailwind CSS](https://tailwindcss.com/)
- [Radix UI](https://www.radix-ui.com/)
- [electron-vite](https://electron-vite.org/)

## License

This project is available for free use, modification, and distribution. Use it however you want to. No warranties or guarantees are provided.

## Contributions

While I'm not actively maintaining this project, feel free to fork it and make your own improvements. If you find it useful, consider sharing your enhancements with others.
</file>

<file path="src/renderer/components/AssetGrid.tsx">
import React, { useState, useEffect } from 'react'
import './AssetGrid.css'
import { FileText, Loader2 } from 'lucide-react'

// Import the FileTreeItem type from global window namespace
declare global {
  interface Window {
    api: {
      navigateToFolder: (folderPath: string) => Promise<{
        success: boolean
        folderPath?: string
        folderName?: string
        message?: string
        children?: FileTreeItem[]
      }>
      selectFolder: () => Promise<{
        success: boolean
        folderPath?: string
        message?: string
      }>
      getAnimationFrames: (
        folderPath: string,
        baseName: string,
        extension: string
      ) => Promise<{
        success: boolean
        frames: Array<{ path: string; name: string }>
        message?: string
      }>
      showAssetContextMenu: (assetPath: string) => Promise<void>
      copyAssetPath: (assetPath: string) => Promise<void>
      showAssetInFolder: (assetPath: string) => Promise<void>
    }
  }
}

interface FileTreeItem {
  id: string
  name: string
  type: 'folder' | 'file'
  path?: string
  isAssetFolder?: boolean
  children?: FileTreeItem[]
}

interface AssetGridProps {
  folderPath?: string
  onAssetSelect: (assetPath: string) => void
}

interface AssetItem {
  id: string
  name: string
  path: string
  type: 'file' | 'folder'
}

const AssetGrid: React.FC<AssetGridProps> = ({ folderPath, onAssetSelect }) => {
  const [assets, setAssets] = useState<AssetItem[]>([])
  const [loading, setLoading] = useState<boolean>(false)
  const [error, setError] = useState<string | null>(null)
  const [selectedAssetId, setSelectedAssetId] = useState<string | null>(null)
  const [sortOption, setSortOption] = useState<'name' | 'date' | 'size'>('name')
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('asc')

  // Function to fetch assets in the folder
  useEffect(() => {
    if (!folderPath) {
      setAssets([])
      return
    }

    const fetchAssets = async (): Promise<void> => {
      setLoading(true)
      setError(null)
      setSelectedAssetId(null) // Clear selection when folder changes

      try {
        const result = await window.api.navigateToFolder(folderPath)

        if (result.success && result.children) {
          // Extract just the files (not folders) from the result
          const fileAssets = extractFileAssetsRecursively(result.children)
          setAssets(fileAssets)

          // Log for debugging
          console.log(`Loaded ${fileAssets.length} assets from ${folderPath}`)
        } else {
          setError(result.message || 'Failed to load assets')
        }
      } catch (err) {
        console.error('Error loading assets:', err)
        setError('An unexpected error occurred')
      } finally {
        setLoading(false)
      }
    }

    fetchAssets()
  }, [folderPath])

  // Extract file assets recursively from the tree structure
  const extractFileAssetsRecursively = (items: FileTreeItem[]): AssetItem[] => {
    const result: AssetItem[] = []

    const processItems = (items: FileTreeItem[]): void => {
      items.forEach((item) => {
        if (item.type === 'file' && item.path) {
          result.push({
            id: item.id,
            name: item.name,
            path: item.path,
            type: 'file'
          })
        } else if (item.children && item.children.length > 0) {
          processItems(item.children)
        }
      })
    }

    processItems(items)
    return result
  }

  // Handle asset selection
  const handleAssetClick = (asset: AssetItem): void => {
    setSelectedAssetId(asset.id)
    onAssetSelect(asset.path)
  }

  // Handle asset right-click
  const handleAssetContextMenu = (e: React.MouseEvent, asset: AssetItem): void => {
    e.preventDefault()
    window.api.showAssetContextMenu(asset.path)
  }

  // Sort assets based on the current sort option
  const sortedAssets = [...assets].sort((a, b) => {
    if (sortOption === 'name') {
      return sortDirection === 'asc' ? a.name.localeCompare(b.name) : b.name.localeCompare(a.name)
    }
    // For now we're just implementing name sorting as required by the Epic
    // Other sorting options will be implemented in future tasks
    return 0
  })

  // Handle sort option change
  const handleSortChange = (option: 'name' | 'date' | 'size'): void => {
    if (option === sortOption) {
      // Toggle direction if clicking the same option
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc')
    } else {
      setSortOption(option)
      setSortDirection('asc')
    }
  }

  // Keyboard navigation
  const handleKeyDown = (e: React.KeyboardEvent, index: number): void => {
    if (!assets.length) return

    if (e.key === 'ArrowRight') {
      const nextIndex = Math.min(index + 1, assets.length - 1)
      const nextAsset = sortedAssets[nextIndex]
      handleAssetClick(nextAsset)
    } else if (e.key === 'ArrowLeft') {
      const prevIndex = Math.max(index - 1, 0)
      const prevAsset = sortedAssets[prevIndex]
      handleAssetClick(prevAsset)
    } else if (e.key === 'ArrowDown') {
      // Assuming a grid with 4 items per row
      const itemsPerRow = 4
      const nextRowIndex = Math.min(index + itemsPerRow, assets.length - 1)
      if (nextRowIndex < assets.length) {
        handleAssetClick(sortedAssets[nextRowIndex])
      }
    } else if (e.key === 'ArrowUp') {
      // Assuming a grid with 4 items per row
      const itemsPerRow = 4
      const prevRowIndex = Math.max(index - itemsPerRow, 0)
      handleAssetClick(sortedAssets[prevRowIndex])
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center h-full w-full">
        <Loader2 className="animate-spin h-6 w-6 mr-2" />
        <span>Loading assets...</span>
      </div>
    )
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-full w-full text-destructive">{error}</div>
    )
  }

  if (!folderPath) {
    return (
      <div className="flex flex-col items-center justify-center h-full w-full text-muted-foreground">
        <FileText className="h-12 w-12 mb-2 opacity-20" />
        <p>No folder selected</p>
        <p className="text-sm mt-2">Click the folder button above to select an asset folder</p>
      </div>
    )
  }

  if (assets.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-full w-full text-muted-foreground">
        <FileText className="h-12 w-12 mb-2 opacity-20" />
        <p>No assets found in this folder</p>
        <p className="text-sm mt-2">Try selecting a different folder</p>
      </div>
    )
  }

  return (
    <div className="asset-grid-container">
      {/* Sort controls */}
      <div className="asset-grid-controls">
        <span className="asset-count">{assets.length} assets</span>
        <div className="sort-controls">
          <button
            className={`sort-button ${sortOption === 'name' ? 'active' : ''}`}
            onClick={() => handleSortChange('name')}
          >
            Name {sortOption === 'name' && (sortDirection === 'asc' ? '↑' : '↓')}
          </button>
          {/* These will be implemented fully in a future task */}
          <button
            className={`sort-button ${sortOption === 'date' ? 'active' : ''}`}
            onClick={() => handleSortChange('date')}
          >
            Date {sortOption === 'date' && (sortDirection === 'asc' ? '↑' : '↓')}
          </button>
          <button
            className={`sort-button ${sortOption === 'size' ? 'active' : ''}`}
            onClick={() => handleSortChange('size')}
          >
            Size {sortOption === 'size' && (sortDirection === 'asc' ? '↑' : '↓')}
          </button>
        </div>
      </div>

      {/* Asset grid */}
      <div className="asset-grid">
        {sortedAssets.map((asset, index) => (
          <div
            key={asset.id}
            className={`asset-item ${selectedAssetId === asset.id ? 'selected' : ''}`}
            onClick={() => handleAssetClick(asset)}
            onContextMenu={(e) => handleAssetContextMenu(e, asset)}
            onKeyDown={(e) => handleKeyDown(e, index)}
            tabIndex={0}
          >
            <div className="asset-thumbnail">
              {/* Use actual image thumbnails when possible */}
              {asset.path && asset.path.match(/\.(png|jpe?g|gif|webp|svg)$/i) ? (
                <img
                  src={`asset://${asset.path}`}
                  alt={asset.name}
                  className="asset-image"
                  onError={(e) => {
                    console.error(`Failed to load thumbnail for ${asset.name}`)
                    // Replace with icon on error
                    e.currentTarget.style.display = 'none'
                    e.currentTarget.parentElement
                      ?.querySelector('.asset-icon-fallback')
                      ?.classList.remove('hidden')
                  }}
                />
              ) : (
                <FileText className="asset-icon" />
              )}
            </div>
            <div className="asset-name" title={asset.name}>
              {asset.name}
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}

export default AssetGrid
</file>

<file path="src/renderer/components/AssetPreview.tsx">
import React, { useState, useEffect, useRef } from 'react'
import './AssetPreview.css'
import { Play, Pause, ChevronLeft, ChevronRight, FastForward, Rewind } from 'lucide-react'

// Add global window type declaration to include the new function
declare global {
  interface Window {
    api: {
      navigateToFolder: (folderPath: string) => Promise<{
        success: boolean
        folderPath?: string
        folderName?: string
        message?: string
        children?: FileTreeItem[]
      }>
      selectFolder: () => Promise<{
        success: boolean
        folderPath?: string
        message?: string
      }>
      getAnimationFrames: (
        folderPath: string,
        baseName: string,
        extension: string
      ) => Promise<{
        success: boolean
        frames: Array<{ path: string; name: string }>
        message?: string
      }>
    }
  }

  // Define the FileTreeItem interface
  interface FileTreeItem {
    id: string
    name: string
    type: 'folder' | 'file'
    path?: string
    children?: FileTreeItem[]
  }
}

// Predefined background options
const BACKGROUND_OPTIONS = [
  { id: 'checkered', label: 'Checkered', color1: '#ffffff', color2: '#cccccc' },
  { id: 'black', label: 'Black', color: '#000000' },
  { id: 'white', label: 'White', color: '#ffffff' },
  { id: 'gray', label: 'Gray', color: '#808080' },
  { id: 'transparent', label: 'Transparent', color: 'transparent' }
]

interface AssetPreviewProps {
  assetPath?: string
  altText?: string
  folderPath?: string // Added to access sibling files for animation sequence detection
}

// Animation related types
interface AnimationFrame {
  path: string
  name: string
}

interface SpriteSheetFrame {
  x: number
  y: number
  width: number
  height: number
}

// Add this new interface for sprite sheet config
interface SpriteSheetConfig {
  rows: number
  columns: number
}

const AssetPreview: React.FC<AssetPreviewProps> = ({
  assetPath,
  folderPath,
  altText = 'Asset preview'
}) => {
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [error, setError] = useState<string | null>(null)
  const [imageDimensions, setImageDimensions] = useState<{ width: number; height: number } | null>(
    null
  )
  const [zoomLevel, setZoomLevel] = useState<number>(100) // Default 100% zoom
  const [backgroundOption, setBackgroundOption] = useState<string>('checkered') // Default to checkered
  const imageRef = useRef<HTMLImageElement>(null)
  const containerRef = useRef<HTMLDivElement>(null)

  // Add pan related states
  const [isPanning, setIsPanning] = useState<boolean>(false)
  const [panOffset, setPanOffset] = useState<{ x: number; y: number }>({ x: 0, y: 0 })
  const [startPanPoint, setStartPanPoint] = useState<{ x: number; y: number }>({ x: 0, y: 0 })

  // Animation related states
  const [isAnimationSequence, setIsAnimationSequence] = useState<boolean>(false)
  const [animationFrames, setAnimationFrames] = useState<AnimationFrame[]>([])
  const [spriteSheetFrames, setIsSpriteSheetFrames] = useState<SpriteSheetFrame[]>([])
  const [isSpriteSheet, setIsSpriteSheet] = useState<boolean>(false)
  const [currentFrameIndex, setCurrentFrameIndex] = useState<number>(0)
  const [isPlaying, setIsPlaying] = useState<boolean>(false)
  const [animationSpeed, setAnimationSpeed] = useState<number>(10) // frames per second
  const animationTimerRef = useRef<number | null>(null)

  // Add sprite sheet configuration state
  const [spriteSheetConfig, setSpriteSheetConfig] = useState<SpriteSheetConfig>({
    rows: 4,
    columns: 4
  })
  const [showSpriteSheetConfig, setShowSpriteSheetConfig] = useState<boolean>(false)

  // Clean up animation timer when component unmounts
  useEffect(() => {
    return () => {
      if (animationTimerRef.current !== null) {
        window.clearInterval(animationTimerRef.current)
      }
    }
  }, [])

  useEffect(() => {
    if (assetPath) {
      setIsLoading(true)
      setError(null)
      // Reset image dimensions and zoom level when a new asset is loaded
      setImageDimensions(null)
      setZoomLevel(100)

      // Stop any existing animation
      stopAnimation()

      // Detect animation sequences when a new asset is loaded
      detectAnimationSequence(assetPath)
    }
  }, [assetPath])

  // Detect animation sequences in the same folder as the selected asset
  const detectAnimationSequence = async (currentAssetPath: string): Promise<void> => {
    if (!folderPath || !currentAssetPath) return

    // Reset animation states
    setIsAnimationSequence(false)
    setAnimationFrames([])
    setIsSpriteSheet(false)
    setIsSpriteSheetFrames([])
    setCurrentFrameIndex(0)
    setIsPlaying(false)
    setShowSpriteSheetConfig(false)

    try {
      // First check if this is a sprite sheet by looking for special naming patterns
      // For example: "character_sheet.png" or "animation_spritesheet.png"
      const fileName = currentAssetPath.split('/').pop()?.toLowerCase() || ''

      if (
        fileName.includes('sheet') ||
        fileName.includes('sprite') ||
        fileName.includes('atlas') ||
        fileName.includes('tileset')
      ) {
        console.log('Detected potential sprite sheet based on filename')
        // We need to wait for the image to load before detecting sprite sheet
        // The actual sprite sheet detection happens in handleImageLoad
        return
      }

      // Otherwise, look for sequence patterns in the filename
      const baseNameMatch = fileName.match(/^(.*?)(?:[-_]?(?:0*(\d+)))?(\.[^.]+)?$/)

      if (baseNameMatch) {
        const baseName = baseNameMatch[1]
        const numberPart = baseNameMatch[2]
        const extension = baseNameMatch[3] || ''

        if (numberPart) {
          // If this file has a number in it, look for other files with the same pattern

          // Use the IPC function to get all animation frames
          try {
            // First, normalize the current asset path to remove the asset:// protocol
            currentAssetPath.replace('asset://', '')

            // Call the IPC function to get animation frames
            // Note: The API type in window.api needs to be updated in the TypeScript definition
            // @ts-ignore - getAnimationFrames is defined in preload but TypeScript doesn't see it
            const result = await window.api.getAnimationFrames(folderPath, baseName, extension)

            if (result.success && result.frames.length > 1) {
              // Map the frames to include the asset:// protocol
              const frames = result.frames.map((frame) => ({
                path: `asset://${frame.path}`,
                name: frame.name
              }))

              setAnimationFrames(frames)
              setIsAnimationSequence(true)
              console.log(`Detected animation sequence with ${frames.length} frames`)
            } else {
              console.log('No animation sequence detected or only one frame found')

              // Fallback to demo mode - this can be removed in production
              if (import.meta.env.DEV) {
                console.log('Using dummy frames for demonstration purposes')
                const dummyFrames: AnimationFrame[] = []
                const frameCount = 5 // For demo purposes
                for (let i = 0; i < frameCount; i++) {
                  dummyFrames.push({
                    path: currentAssetPath, // In a real app, these would be different paths
                    name: `${baseName}_${String(i).padStart(2, '0')}${extension}`
                  })
                }
                setAnimationFrames(dummyFrames)
                setIsAnimationSequence(true)
              }
            }
          } catch (error) {
            console.error('Error calling getAnimationFrames:', error)
          }
        }
      }
    } catch (error) {
      console.error('Error detecting animation sequence:', error)
    }
  }

  // Detect sprite sheet animation frames
  const detectSpriteSheet = async (filePath: string): Promise<void> => {
    try {
      console.log(`Detecting sprite sheet from: ${filePath}`)

      // Only process if we have image dimensions
      if (imageRef.current && imageDimensions) {
        const imgWidth = imageDimensions.width
        const imgHeight = imageDimensions.height

        // Use the configuration from state
        const framesPerRow = spriteSheetConfig.columns
        const numRows = spriteSheetConfig.rows

        const frameWidth = imgWidth / framesPerRow
        const frameHeight = imgHeight / numRows

        const frames: SpriteSheetFrame[] = []

        for (let row = 0; row < numRows; row++) {
          for (let col = 0; col < framesPerRow; col++) {
            frames.push({
              x: col * frameWidth,
              y: row * frameHeight,
              width: frameWidth,
              height: frameHeight
            })
          }
        }

        if (frames.length > 0) {
          setIsSpriteSheetFrames(frames)
          setIsSpriteSheet(true)
          console.log(`Detected sprite sheet with ${frames.length} frames`)
          // Show the configuration UI when a sprite sheet is detected
          setShowSpriteSheetConfig(true)
        }
      }
    } catch (error) {
      console.error('Error detecting sprite sheet:', error)
    }
  }

  // Start animation playback
  const startAnimation = (): void => {
    if (animationTimerRef.current !== null) {
      window.clearInterval(animationTimerRef.current)
    }

    const intervalMs = 1000 / animationSpeed

    animationTimerRef.current = window.setInterval(() => {
      setCurrentFrameIndex((prev) => {
        const maxFrames = isSpriteSheet ? spriteSheetFrames.length : animationFrames.length

        return (prev + 1) % maxFrames
      })
    }, intervalMs)

    setIsPlaying(true)
  }

  // Stop animation playback
  const stopAnimation = (): void => {
    if (animationTimerRef.current !== null) {
      window.clearInterval(animationTimerRef.current)
      animationTimerRef.current = null
    }

    setIsPlaying(false)
  }

  // Go to next frame
  const nextFrame = (): void => {
    const maxFrames = isSpriteSheet ? spriteSheetFrames.length : animationFrames.length

    setCurrentFrameIndex((prev) => (prev + 1) % maxFrames)
  }

  // Go to previous frame
  const prevFrame = (): void => {
    const maxFrames = isSpriteSheet ? spriteSheetFrames.length : animationFrames.length

    setCurrentFrameIndex((prev) => (prev - 1 + maxFrames) % maxFrames)
  }

  // Handle speed change
  const handleSpeedChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const newSpeed = parseInt(e.target.value, 10)
    setAnimationSpeed(newSpeed)

    // If already playing, restart with new speed
    if (isPlaying) {
      stopAnimation()
      startAnimation()
    }
  }

  // Toggle play/pause
  const togglePlayPause = (): void => {
    if (isPlaying) {
      stopAnimation()
    } else {
      startAnimation()
    }
  }

  // Handle image load to set actual dimensions
  const handleImageLoad = (): void => {
    setIsLoading(false)
    setError(null)

    if (imageRef.current) {
      // Get natural dimensions of the image
      const { naturalWidth, naturalHeight } = imageRef.current
      setImageDimensions({ width: naturalWidth, height: naturalHeight })

      // If this might be a sprite sheet based on the filename, try to detect it now
      if (assetPath) {
        const fileName = assetPath.split('/').pop()?.toLowerCase() || ''
        if (
          fileName.includes('sheet') ||
          fileName.includes('sprite') ||
          fileName.includes('atlas') ||
          fileName.includes('tileset')
        ) {
          detectSpriteSheet(assetPath)
        }
      }
    }
  }

  // Handle mouse wheel for zooming
  const handleWheel = (e: React.WheelEvent<HTMLDivElement>): void => {
    // Prevent the default scroll behavior
    e.preventDefault()

    // Determine the direction of the wheel
    const delta = Math.sign(e.deltaY) * -1

    // Calculate the new zoom level
    // Delta is either 1 or -1
    // For zoom in/out, change by 10% per wheel tick
    const zoomChange = delta * 10
    const newZoom = Math.max(10, Math.min(400, zoomLevel + zoomChange))

    // Update the zoom level
    setZoomLevel(newZoom)
  }

  // Get background style based on selected option
  const getBackgroundStyle = (): React.CSSProperties => {
    const option = BACKGROUND_OPTIONS.find((opt) => opt.id === backgroundOption)

    if (!option) {
      return {} // Default empty style
    }

    if (backgroundOption === 'checkered') {
      return {
        backgroundImage: `
          linear-gradient(45deg, ${option.color2} 25%, transparent 25%), 
          linear-gradient(-45deg, ${option.color2} 25%, transparent 25%), 
          linear-gradient(45deg, transparent 75%, ${option.color2} 75%), 
          linear-gradient(-45deg, transparent 75%, ${option.color2} 75%)
        `,
        backgroundSize: '20px 20px',
        backgroundPosition: '0 0, 0 10px, 10px -10px, -10px 0px',
        backgroundColor: option.color1
      }
    }

    return {
      // For non-checkered backgrounds, remove the checkered pattern
      backgroundImage: 'none',
      backgroundColor: option.color
    }
  }

  // Handle background change
  const handleBackgroundChange = (optionId: string): void => {
    setBackgroundOption(optionId)
  }

  // Add handler for sprite sheet config changes
  const handleSpriteSheetConfigChange = (field: keyof SpriteSheetConfig, value: number): void => {
    // Ensure value is at least 1
    const validValue = Math.max(1, value)

    setSpriteSheetConfig((prev) => ({
      ...prev,
      [field]: validValue
    }))

    // Re-detect the sprite sheet with the new configuration
    if (assetPath && isSpriteSheet) {
      detectSpriteSheet(assetPath)
    }
  }

  // Get image style for sprite sheet frames
  const getSpriteSheetImageStyle = (): React.CSSProperties => {
    if (
      !isSpriteSheet ||
      spriteSheetFrames.length === 0 ||
      !imageDimensions || // Ensure image metadata is loaded
      currentFrameIndex < 0 ||
      currentFrameIndex >= spriteSheetFrames.length
    ) {
      return {}
    }

    const currentDisplayFrame = spriteSheetFrames[currentFrameIndex]
    // Assuming all frames in a spritesheet share the same dimensions.
    // Use the first frame to determine the size of our "masking" viewport.
    const maskFrameDimensions = spriteSheetFrames[0]
    const zoom = zoomLevel / 100

    return {
      // Set the <img> element's dimensions to that of a single frame (the "mask").
      width: `${maskFrameDimensions.width}px`,
      height: `${maskFrameDimensions.height}px`,
      objectFit: 'none', // This is critical for objectPosition to work as intended.

      // Shift the full spritesheet image. The part of the image at
      // (currentDisplayFrame.x, currentDisplayFrame.y) will be aligned
      // with the top-left of our (now smaller) <img> element.
      // This animates the content within the mask.
      objectPosition: `-${currentDisplayFrame.x}px -${currentDisplayFrame.y}px`,

      // Apply zoom and pan transformations to the masked, animating frame.
      transform: `scale(${zoom}) translate(${panOffset.x / zoom}px, ${panOffset.y / zoom}px)`,
      transformOrigin: 'top left' // Ensures transforms originate from the top-left of the mask.
    }
  }

  // Add a manual toggle for sprite sheet mode
  const toggleSpriteSheetMode = (): void => {
    if (isSpriteSheet) {
      // Turn off sprite sheet mode
      setIsSpriteSheet(false)
      setIsSpriteSheetFrames([])
      setShowSpriteSheetConfig(false)
    } else if (assetPath && imageDimensions) {
      // Turn on sprite sheet mode
      detectSpriteSheet(assetPath)
    }
  }

  // Add mouse down handler for starting panning
  const handleMouseDown = (e: React.MouseEvent<HTMLDivElement>): void => {
    // Only start panning if we're zoomed in (zoomLevel > 100)
    if (zoomLevel <= 100) return

    // Set panning flag and capture start position
    setIsPanning(true)
    setStartPanPoint({ x: e.clientX, y: e.clientY })
  }

  // Add mouse move handler for panning
  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>): void => {
    // Only pan if we're in panning mode
    if (!isPanning) return

    // Calculate the movement delta
    const dx = e.clientX - startPanPoint.x
    const dy = e.clientY - startPanPoint.y

    // Update the pan offset
    setPanOffset({ x: panOffset.x + dx, y: panOffset.y + dy })

    // Update the start point for the next move
    setStartPanPoint({ x: e.clientX, y: e.clientY })
  }

  // Add mouse up/out handler to stop panning
  const handleMouseUp = (): void => {
    setIsPanning(false)
  }

  // Reset pan offset when zoom level or asset changes
  useEffect(() => {
    setPanOffset({ x: 0, y: 0 })
  }, [zoomLevel, assetPath])

  // Get style for the image-container div
  const getContainerStyle = (): React.CSSProperties => {
    const baseStyle = getBackgroundStyle()
    return {
      ...baseStyle,
      cursor: isPanning ? 'grabbing' : zoomLevel > 100 ? 'grab' : 'default'
    }
  }

  if (!assetPath) {
    return (
      <div className="asset-preview empty-state">
        <p>No asset selected</p>
        <p className="text-sm text-muted-foreground">Select an image from the file tree</p>
      </div>
    )
  }

  return (
    <div className="asset-preview">
      {isLoading && (
        <div className="loading-indicator">
          <span>Loading...</span>
        </div>
      )}

      {error && (
        <div className="error-message">
          <p>{error}</p>
        </div>
      )}

      {/* Controls panel */}
      <div className="controls-panel">
        {/* Zoom info */}
        {imageDimensions && (
          <div className="zoom-info">
            <span>
              {imageDimensions.width} × {imageDimensions.height} px
            </span>
            <span>|</span>
            <span>{zoomLevel}%</span>
            {/* Add sprite sheet toggle button */}
            <button
              className="sprite-sheet-toggle"
              onClick={toggleSpriteSheetMode}
              title={isSpriteSheet ? 'Disable Sprite Sheet Mode' : 'Enable Sprite Sheet Mode'}
            >
              {isSpriteSheet ? 'Exit Sprite Sheet' : 'Sprite Sheet'}
            </button>
          </div>
        )}

        {/* Sprite Sheet Configuration */}
        {showSpriteSheetConfig && (
          <div className="sprite-sheet-config">
            <div className="config-title">Sprite Sheet Settings</div>
            <div className="config-controls">
              <label>
                Rows:
                <input
                  type="number"
                  min="1"
                  value={spriteSheetConfig.rows}
                  onChange={(e) =>
                    handleSpriteSheetConfigChange('rows', parseInt(e.target.value, 10))
                  }
                />
              </label>
              <label>
                Columns:
                <input
                  type="number"
                  min="1"
                  value={spriteSheetConfig.columns}
                  onChange={(e) =>
                    handleSpriteSheetConfigChange('columns', parseInt(e.target.value, 10))
                  }
                />
              </label>
              <button
                className="apply-button"
                onClick={() => {
                  if (assetPath) detectSpriteSheet(assetPath)
                }}
              >
                Apply
              </button>
            </div>
          </div>
        )}

        {/* Animation controls - only show if animation sequence detected */}
        {(isAnimationSequence || isSpriteSheet) && (
          <div className="animation-controls">
            <button className="icon-button" onClick={prevFrame} title="Previous Frame">
              <ChevronLeft size={16} />
            </button>

            <button
              className="icon-button"
              onClick={togglePlayPause}
              title={isPlaying ? 'Pause' : 'Play'}
            >
              {isPlaying ? <Pause size={16} /> : <Play size={16} />}
            </button>

            <button className="icon-button" onClick={nextFrame} title="Next Frame">
              <ChevronRight size={16} />
            </button>

            <div className="speed-control">
              <Rewind size={14} />
              <input
                type="range"
                min="1"
                max="30"
                value={animationSpeed}
                onChange={handleSpeedChange}
                title={`Animation Speed: ${animationSpeed} FPS`}
              />
              <FastForward size={14} />
            </div>

            <div className="frame-counter">
              Frame {currentFrameIndex + 1} of{' '}
              {isSpriteSheet ? spriteSheetFrames.length : animationFrames.length}
            </div>
          </div>
        )}

        {/* Background options */}
        <div className="background-options">
          <label>Background:</label>
          <div className="background-buttons">
            {BACKGROUND_OPTIONS.map((option) => (
              <button
                key={option.id}
                className={`bg-option ${backgroundOption === option.id ? 'active' : ''}`}
                title={option.label}
                onClick={() => handleBackgroundChange(option.id)}
                style={{
                  backgroundColor: option.color || (option.id === 'checkered' ? '#ccc' : undefined),
                  backgroundImage:
                    option.id === 'checkered'
                      ? 'linear-gradient(45deg, #fff 50%, transparent 50%)'
                      : undefined
                }}
              />
            ))}
          </div>
        </div>
      </div>

      <div
        ref={containerRef}
        className="image-container"
        onWheel={handleWheel}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        style={getContainerStyle()}
      >
        <img
          ref={imageRef}
          src={
            isSpriteSheet
              ? assetPath
              : isAnimationSequence
                ? animationFrames[currentFrameIndex]?.path
                : assetPath
          }
          alt={altText}
          className="preview-image"
          style={
            isSpriteSheet
              ? getSpriteSheetImageStyle()
              : {
                  // Set the image size based on zoom level while maintaining aspect ratio
                  width: imageDimensions
                    ? `${imageDimensions.width * (zoomLevel / 100)}px`
                    : 'auto',
                  height: imageDimensions
                    ? `${imageDimensions.height * (zoomLevel / 100)}px`
                    : 'auto',
                  transform:
                    zoomLevel > 100 ? `translate(${panOffset.x}px, ${panOffset.y}px)` : 'none'
                }
          }
          onLoad={handleImageLoad}
          onError={(e) => {
            console.error('Image failed to load:', e)
            setIsLoading(false)
            setError(`Failed to load image: ${assetPath}`)
          }}
        />
      </div>
    </div>
  )
}

export default AssetPreview
</file>

<file path="src/main/index.ts">
import { app, shell, BrowserWindow, ipcMain, dialog, protocol, Menu, clipboard } from 'electron'
import { join, normalize, extname } from 'path'
import { electronApp, optimizer, is } from '@electron-toolkit/utils'
import icon from '../../resources/icon.png?asset'
import { existsSync, statSync, readdirSync } from 'fs'

// Register the asset:// protocol as privileged - MUST be called before app is ready
protocol.registerSchemesAsPrivileged([
  {
    scheme: 'asset',
    privileges: {
      standard: true,
      supportFetchAPI: true,
      secure: true,
      bypassCSP: true, // This is the key property to bypass CSP restrictions
      corsEnabled: true
    }
  }
])

function createWindow(): void {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 900,
    height: 670,
    show: false,
    autoHideMenuBar: true,
    ...(process.platform === 'linux' ? { icon } : {}),
    webPreferences: {
      preload: join(__dirname, '../preload/index.js'),
      sandbox: false
    }
  })

  mainWindow.on('ready-to-show', () => {
    mainWindow.show()
  })

  mainWindow.webContents.setWindowOpenHandler((details) => {
    shell.openExternal(details.url)
    return { action: 'deny' }
  })

  // HMR for renderer base on electron-vite cli.
  // Load the remote URL for development or the local html file for production.
  if (is.dev && process.env['ELECTRON_RENDERER_URL']) {
    mainWindow.loadURL(process.env['ELECTRON_RENDERER_URL'])
  } else {
    mainWindow.loadFile(join(__dirname, '../renderer/index.html'))
  }
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(() => {
  // Set app user model id for windows
  electronApp.setAppUserModelId('com.electron')

  // Register the asset:// protocol for loading local files
  // This is needed for the AssetPreview component to display local images
  protocol.registerFileProtocol('asset', (request, callback) => {
    const url = request.url.replace('asset://', '')
    try {
      // Decode the URL to handle spaces and special characters
      const decodedUrl = decodeURI(url)
      return callback(decodedUrl)
    } catch (error) {
      console.error('Protocol handler error:', error)
    }
  })

  // Default open or close DevTools by F12 in development
  // and ignore CommandOrControl + R in production.
  // see https://github.com/alex8088/electron-toolkit/tree/master/packages/utils
  app.on('browser-window-created', (_, window) => {
    optimizer.watchWindowShortcuts(window)
  })

  // IPC test
  ipcMain.on('ping', () => console.log('pong'))

  // Handle getting paths from drag events
  ipcMain.handle('drag-dropped-files', async () => {
    try {
      // In some cases, we need to use a workaround to get file paths from drag events
      // This is a placeholder - in a real implementation, you'd need to capture these paths
      // when they're first dragged into the app window

      // For now, let's just return an empty array as we'll be relying on the renderer's path access
      console.log('Requesting drag-dropped files from main process')
      return []
    } catch (error: unknown) {
      console.error('Error handling drag-dropped-files:', error)
      return []
    }
  })

  // Handle folder selection dialog
  ipcMain.handle('select-folder', async () => {
    try {
      const mainWindow = BrowserWindow.getFocusedWindow()
      if (!mainWindow) {
        return { success: false, message: 'No active window found' }
      }

      const result = await dialog.showOpenDialog(mainWindow, {
        properties: ['openDirectory'],
        title: 'Select Folder to Navigate',
        buttonLabel: 'Select Folder'
      })

      if (result.canceled || result.filePaths.length === 0) {
        return { success: false, message: 'Folder selection canceled' }
      }

      const folderPath = result.filePaths[0]
      console.log('Selected folder path:', folderPath)

      return { success: true, folderPath }
    } catch (error: unknown) {
      console.error('Error selecting folder:', error)
      const errorMessage = error instanceof Error ? error.message : String(error)
      return { success: false, message: errorMessage }
    }
  })

  // Define the recursive type first
  interface FileTreeItem {
    id: string
    name: string
    type: 'folder' | 'file'
    path: string
    isAssetFolder?: boolean
    children?: FileTreeItem[]
  }

  // Define interface for animation frame detection
  interface AnimationFrame {
    path: string
    name: string
  }

  // Handle folder navigation
  ipcMain.handle('navigate-to-folder', async (_, folderPath) => {
    try {
      console.log('Received folder path:', folderPath, 'Type:', typeof folderPath)

      // Validate the folder path with better error messaging
      if (!folderPath || typeof folderPath !== 'string') {
        return { success: false, message: 'No folder path provided or invalid path type' }
      }

      // Normalize the path using Node's path module
      const normalizedPath = normalize(folderPath)
      console.log('Normalized path:', normalizedPath)

      if (!existsSync(normalizedPath)) {
        return { success: false, message: `Path does not exist: ${normalizedPath}` }
      }

      try {
        const stats = statSync(normalizedPath)
        if (!stats.isDirectory()) {
          return {
            success: false,
            message: 'Selected item is not a directory. Please select a folder.'
          }
        }
      } catch (statError) {
        console.error('Error checking if path is directory:', statError)
        return { success: false, message: 'Unable to determine if path is a directory' }
      }

      // Function to scan directory and build tree structure
      const scanDirectory = (
        dirPath: string,
        depth = 0,
        maxDepth = 5 // Limit recursion depth for performance
      ): FileTreeItem[] => {
        try {
          // If we've reached maximum depth, stop recursion
          if (depth > maxDepth) {
            console.log(`Max depth reached at ${dirPath}, stopping recursion`)
            return []
          }

          console.log(`Scanning directory at depth ${depth}: ${dirPath}`)
          const entries = readdirSync(dirPath, { withFileTypes: true })
          console.log(`Found ${entries.length} entries in ${dirPath}`)

          const items = entries
            .map((entry) => {
              const entryPath = join(dirPath, entry.name)

              if (entry.isDirectory()) {
                console.log(`Found subdirectory: ${entry.name} at path ${entryPath}`)
                // Recursively scan subdirectories
                const subDirItems = scanDirectory(entryPath, depth + 1, maxDepth)
                console.log(`Subdirectory ${entry.name} has ${subDirItems.length} items`)

                return {
                  id: `folder-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                  name: entry.name,
                  type: 'folder' as const,
                  isAssetFolder: true,
                  path: entryPath,
                  children: subDirItems
                }
              } else {
                // Only include image files
                const ext = extname(entry.name).toLowerCase()
                const isImageFile = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg'].includes(ext)

                if (isImageFile) {
                  console.log(`Found image file: ${entry.name}`)
                  return {
                    id: `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    name: entry.name,
                    type: 'file' as const,
                    path: entryPath
                  }
                }
                return null
              }
            })
            .filter(Boolean) // Remove null entries (non-image files)

          console.log(`Returning ${items.length} items from ${dirPath}`)
          return items as FileTreeItem[]
        } catch (err) {
          console.error(`Error scanning directory ${dirPath}:`, err)
          return []
        }
      }

      // Get the folder name from the path
      const folderName = normalizedPath.split(/[/\\]/).pop() || 'Selected Folder'

      // Scan top-level contents
      console.log('Starting recursive directory scan for:', normalizedPath)
      const children = scanDirectory(normalizedPath)
      console.log(`Completed scan, found ${children.length} top-level items`)

      // Log detailed tree structure up to 3 levels for debugging
      const logTreeStructure = (items: FileTreeItem[], level = 0, maxLevel = 3): void => {
        if (level > maxLevel) return

        items.forEach((item) => {
          console.log(
            '  '.repeat(level) +
              `- ${item.type}: ${item.name} (${item.children?.length || 0} children)`
          )
          if (item.children && item.children.length > 0) {
            logTreeStructure(item.children, level + 1, maxLevel)
          }
        })
      }

      console.log('File tree structure:')
      logTreeStructure(children)

      // Return success with folder path and structure data
      return {
        success: true,
        folderPath: normalizedPath,
        folderName: folderName,
        children: children
      }
    } catch (error: unknown) {
      console.error('Error navigating to folder:', error)
      const errorMessage = error instanceof Error ? error.message : String(error)
      return { success: false, message: errorMessage }
    }
  })

  // After defining your other IPC handlers
  // Add this handler to get animation frames
  ipcMain.handle('get-animation-frames', async (_, folderPath, baseName, extension) => {
    try {
      if (!folderPath || !existsSync(folderPath)) {
        return { success: false, message: 'Invalid folder path', frames: [] }
      }

      // Get all files in the directory
      const files = readdirSync(folderPath, { withFileTypes: true })
        .filter((file) => file.isFile())
        .map((file) => file.name)

      // Create a regex pattern to match files with the same base name but different sequence numbers
      // This handles patterns like:
      // - walk_01.png, walk_02.png
      // - run-1.png, run-2.png
      // - jump001.png, jump002.png
      const regexPattern = new RegExp(
        `^${baseName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}[-_]?\\d+${extension}$`
      )

      // Filter files that match the pattern
      const frameFiles = files.filter((file) => regexPattern.test(file))

      // Sort them numerically by the sequence number
      frameFiles.sort((a, b) => {
        // Extract number from filename
        const numA = parseInt(a.replace(/[^\d]/g, ''), 10)
        const numB = parseInt(b.replace(/[^\d]/g, ''), 10)
        return numA - numB
      })

      // Map to full paths
      const frames: AnimationFrame[] = frameFiles.map((file) => ({
        path: join(folderPath, file),
        name: file
      }))

      return {
        success: true,
        frames,
        message: `Found ${frames.length} animation frames`
      }
    } catch (error) {
      console.error('Error getting animation frames:', error)
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error',
        frames: []
      }
    }
  })

  // Handle asset context menu
  ipcMain.handle('show-asset-context-menu', async (_, assetPath) => {
    const template = [
      {
        label: 'Copy Path',
        click: () => {
          clipboard.writeText(assetPath)
        }
      },
      {
        label: 'Copy File',
        click: () => {
          clipboard.writeBuffer('public.file-url', Buffer.from(assetPath))
        }
      },
      {
        label: 'Show in Folder',
        click: () => {
          shell.showItemInFolder(assetPath)
        }
      }
    ]

    const menu = Menu.buildFromTemplate(template)
    menu.popup()
  })

  // Handle copy asset path
  ipcMain.handle('copy-asset-path', async (_, assetPath) => {
    clipboard.writeText(assetPath)
  })

  // Handle copy asset file
  ipcMain.handle('copy-asset-file', async (_, assetPath) => {
    clipboard.writeBuffer('public.file-url', Buffer.from(assetPath))
  })

  // Handle show asset in folder
  ipcMain.handle('show-asset-in-folder', async (_, assetPath) => {
    shell.showItemInFolder(assetPath)
  })

  createWindow()

  app.on('activate', function () {
    // On macOS it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  })
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and require them here.
</file>

<file path=".cursor-updates">
# Cursor Updates

- Implemented folder navigation feature allowing users to navigate to selected folders in the file tree
- Removed drag-and-drop functionality due to compatibility issues
- Added a folder picker button that reliably handles folder selection across platforms
- Fixed issue with tree population after folder selection
- Implemented Asset Preview component with transparency rendering for PNG images (Epic 2)
- Added protocol handler to load local images with transparency properly displayed
- Implemented default sizing feature to show sprites at actual pixel dimensions
- Added aspect ratio maintenance for proper image display
- Added customizable transparency background with multiple options (checkered, black, white, gray, transparent)
- Implemented mouse wheel zoom functionality with zoom level display
- Fixed asset protocol handling by registering it as a privileged scheme before app ready to bypass CSP restrictions
- Implemented animation preview features for Epic 6:
  - Added detection for frame sequence animations and sprite sheets
  - Added animation playback controls (play/pause, next/prev frames)
  - Implemented animation speed control with adjustable FPS
  - Added frame counter display showing current frame and total frames
  - Created IPC handler for detecting related animation frames in a sequence
- Refactored FileTreeSidebar to use ShadCN UI components, removing the need for the CSS file.
- Updated sidebar width to a minimum of 400px for better usability with longer filenames.
- Refactored sidebar to use ShadCN Sheet component, making it collapsible with a toggle button.
- Replaced custom Sheet-based sidebar with native ShadCN Sidebar component for improved collapsibility and navigation.
- Fixed layout issues by properly implementing SidebarProvider at the App level to maintain content structure.
- Improved main content layout with proper sizing and empty states for better user experience.
- Added tooltips to file tree items showing full file paths on hover for better navigation.
- Added tooltips to file tree items showing file names on hover and improved truncation.
- Added context menu functionality to AssetGrid component with options to copy asset path and show in folder
- Added "Copy File" option to context menu for copying actual files to clipboard
</file>

<file path="tasks.md">
# 2D Sprite Asset Viewer User Stories

## Epic 1: File System Navigation (F1)

- [x] **Folder Tree Display** (Priority: Critical 1)

  - As a game developer, I want to see a collapsible folder tree in the sidebar, so that I can navigate my file system easily.
  - **Acceptance Criteria**:
    - Given the application is open, when I look at the sidebar, then I should see a folder tree representing my file system.
    - Given a folder is visible in the sidebar, when I click on the expansion arrow, then its subfolders should be displayed.
  - **Dependencies**: None

- [x] **Folder Expansion/Collapse** (Priority: Critical 1)

  - As a game developer, I want to expand and collapse folder nodes, so that I can focus on relevant directories.
  - **Acceptance Criteria**:
    - Given a collapsed folder, when I click on it, then it should expand to show its contents.
    - Given an expanded folder, when I click on it again, then it should collapse.
  - **Dependencies**: Folder Tree Display

- [x] **Folder Content Indicators** (Priority: Medium 3)

  - As a game developer, I want visual indicators for folders containing sprite assets, so that I can quickly identify relevant directories.
  - **Acceptance Criteria**:
    - Given a folder contains sprite assets, when I view the folder tree, then that folder should have a distinct visual indicator.
  - **Dependencies**: Folder Tree Display

- [x] **Drag-and-Drop Navigation** (Priority: Low 4)

  - As a game developer, I want to use drag-and-drop for folder navigation, so that I can work more efficiently.
  - **Acceptance Criteria**:
    - Given I have the application open, when I drag a folder from my system's file explorer into the app, then the application should navigate to that folder.
  - **Dependencies**: Folder Tree Display

- [x] **Last Folder Memory** (Priority: Medium 3)
  - As a game developer, I want the application to remember my last visited folder, so that I can resume my work quickly after restarting.
  - **Acceptance Criteria**:
    - Given I have previously browsed to a specific folder, when I reopen the application, then it should automatically navigate to that folder.
  - **Dependencies**: Folder Tree Display

## Epic 2: Asset Preview (F2)

- [x] **Transparency Rendering** (Priority: Critical 1)

  - As a game artist, I want PNG images to render with transparency properly, so that I can accurately assess how sprites will look in-game.
  - **Acceptance Criteria**:
    - Given I select a PNG with transparency, when it loads in the preview area, then transparent areas should be displayed with a checkered background.
  - **Dependencies**: Asset Selection

- [x] **Default Sizing** (Priority: High 2)

  - As a game artist, I want sprites to display at actual size by default, so that I can see their true dimensions.
  - **Acceptance Criteria**:
    - Given I select a sprite, when it loads in the preview area, then it should display at 100% of its actual pixel dimensions.
    - Given a sprite is displayed, when I check the zoom indicator, then it should show "100%".
  - **Dependencies**: Transparency Rendering

- [x] **Aspect Ratio Maintenance** (Priority: High 2)

  - As a game artist, I want the preview to maintain aspect ratio when resizing, so that sprites don't appear distorted.
  - **Acceptance Criteria**:
    - Given a sprite is displayed, when I resize the preview window, then the sprite should maintain its original aspect ratio.
  - **Dependencies**: Default Sizing

- [x] **Transparency Background Customization** (Priority: Medium 3)
  - As a game artist, I want to customize the background color for transparency, so that I can better visualize sprites against different backgrounds.
  - **Acceptance Criteria**:
    - Given I am viewing a sprite with transparency, when I select a different background color from the settings, then the transparent areas should display with that color instead of the default checkered pattern.
  - **Dependencies**: Transparency Rendering

## Epic 3: Asset Browsing (F3)

- [x] **Folder Content Display** (Priority: Critical 1)

  - As a game developer, I want to see all compatible assets in my selected folder, so that I can browse available sprites.
  - **Acceptance Criteria**:
    - Given I select a folder, when the folder loads, then all compatible sprite assets should be displayed in the content area.
  - **Dependencies**: Folder Tree Display

- [x] **Vertical Scrolling** (Priority: High 2)

  - As a game developer, I want to scroll vertically through my asset list, so that I can navigate large collections efficiently.
  - **Acceptance Criteria**:
    - Given a folder contains more assets than can be displayed at once, when I use the scroll wheel or scroll bar, then the asset list should scroll vertically.
  - **Dependencies**: Folder Content Display

- [x] **Filename Display** (Priority: High 2)

  - As a game developer, I want to see filenames displayed below asset thumbnails, so that I can identify assets by name.
  - **Acceptance Criteria**:
    - Given assets are displayed in the content area, when I look at an asset thumbnail, then I should see its filename displayed below it.
  - **Dependencies**: Folder Content Display

- [x] **Alphabetical Sorting** (Priority: Medium 3)

  - As a game developer, I want assets sorted alphabetically by default, so that I can find specific assets easily.
  - **Acceptance Criteria**:
    - Given assets are displayed in the content area, when I first open a folder, then assets should be sorted alphabetically by filename.
  - **Dependencies**: Folder Content Display

- [x] **Sort Options** (Priority: Low 4)
  - As a game developer, I want to sort assets by different criteria, so that I can organize them according to my needs.
  - **Acceptance Criteria**:
    - Given assets are displayed, when I click a sort option (name, size, date modified), then the assets should reorder according to that criterion.
  - **Dependencies**: Alphabetical Sorting

## Epic 4: Basic Image Controls (F4)

- [x] **Mouse Wheel Zoom** (Priority: High 2)

  - As a game artist, I want to zoom in/out of sprites via mouse wheel, so that I can examine details or get an overview quickly.
  - **Acceptance Criteria**:
    - Given a sprite is displayed in the preview area, when I scroll the mouse wheel up, then the sprite should zoom in.
    - Given a sprite is displayed in the preview area, when I scroll the mouse wheel down, then the sprite should zoom out.
  - **Dependencies**: Default Sizing

- [x] **Pan When Zoomed** (Priority: High 2)

  - As a game artist, I want to pan the view when zoomed in, so that I can navigate to different parts of larger sprites.
  - **Acceptance Criteria**:
    - Given a sprite is zoomed in beyond the preview area's boundaries, when I click and drag within the preview area, then the view should pan in the direction of the drag.
  - **Dependencies**: Mouse Wheel Zoom

- [x] **Zoom Control Buttons** (Priority: Medium 3)

  - As a game artist, I want zoom in, zoom out, and reset buttons, so that I have precise control over the zoom level.
  - **Acceptance Criteria**:
    - Given a sprite is displayed, when I click the zoom in button, then the sprite should increase in size.
    - Given a sprite is displayed, when I click the zoom out button, then the sprite should decrease in size.
    - Given a sprite is zoomed in or out, when I click the reset button, then the sprite should return to 100% zoom.
  - **Dependencies**: Mouse Wheel Zoom

- [x] **Image Quality Maintenance** (Priority: High 2)

  - As a game artist, I want the application to maintain image quality during zoom operations, so that I can accurately assess pixel-level details.
  - **Acceptance Criteria**:
    - Given a sprite is displayed, when I zoom in, then the pixel boundaries should remain sharp without blurring or interpolation artifacts.
  - **Dependencies**: Mouse Wheel Zoom

- [x] **Fit to View** (Priority: Medium 3)
  - As a game developer, I want a shortcut to fit the image to the current view, so that I can quickly see the entire sprite.
  - **Acceptance Criteria**:
    - Given a sprite is displayed at any zoom level, when I press the "fit to view" button or shortcut, then the sprite should resize to fit entirely within the preview area while maintaining its aspect ratio.
  - **Dependencies**: Default Sizing

## Epic 5: Asset Selection (F6)

- [ ] **Selection Highlighting** (Priority: Critical 1)

  - As a game developer, I want the currently selected asset to be highlighted, so that I can easily identify which asset I'm working with.
  - **Acceptance Criteria**:
    - Given multiple assets are displayed, when I click on an asset, then it should be visually highlighted to indicate selection.
  - **Dependencies**: Folder Content Display

- [ ] **Keyboard Navigation** (Priority: Medium 3)

  - As a game developer, I want to use keyboard navigation between assets, so that I can browse efficiently without using the mouse.
  - **Acceptance Criteria**:
    - Given assets are displayed, when I press the arrow keys, then the selection should move to the next asset in that direction.
  - **Dependencies**: Selection Highlighting

- [ ] **Preview Loading** (Priority: Critical 1)

  - As a game developer, I want the selected asset to load in the preview area, so that I can examine it in detail.
  - **Acceptance Criteria**:
    - Given I select an asset, when the selection changes, then the preview area should immediately load and display the selected asset.
  - **Dependencies**: Selection Highlighting, Transparency Rendering

- [ ] **Multi-Select Support** (Priority: Low 4)

  - As a team lead, I want to select multiple assets via Shift/Ctrl+click, so that I can perform operations on groups of sprites.
  - **Acceptance Criteria**:
    - Given assets are displayed, when I hold Shift and click a second asset, then all assets between the first and second should be selected.
    - Given assets are displayed, when I hold Ctrl and click various assets, then each clicked asset should be added to the selection.
  - **Dependencies**: Selection Highlighting

- [ ] **Selection Persistence** (Priority: Low 4)
  - As a game developer, I want the selection state to be maintained when changing sort order, so that I don't lose my place when organizing assets.
  - **Acceptance Criteria**:
    - Given I have assets selected, when I change the sort order, then the same assets should remain selected after reordering.
  - **Dependencies**: Sort Options, Selection Highlighting

## Epic 6: Animation Preview (F7)

- [x] **Animation Sequence Detection** (Priority: High 2)

  - As a game artist, I want the application to detect frame-based animation sequences, so that I can preview animations easily.
  - **Acceptance Criteria**:
    - Given a folder contains numbered sprite frames (e.g., run_01.png, run_02.png), when I select the first frame, then the application should recognize it as part of an animation sequence and display animation controls.
    - This needs to also work for sprites frames in a single image
  - **Dependencies**: Selection Highlighting

- [x] **Animation Playback Controls** (Priority: High 2)

  - As a game artist, I want play/pause controls for animations, so that I can view sprite animations in action.
  - **Acceptance Criteria**:
    - Given an animation sequence is detected, when I click the play button, then the frames should play in sequence at the default speed.
    - Given an animation is playing, when I click the pause button, then the animation should stop on the current frame.
  - **Dependencies**: Animation Sequence Detection

- [x] **Animation Speed Control** (Priority: Medium 3)

  - As a game artist, I want to adjust animation playback speed, so that I can evaluate animations at different rates.
  - **Acceptance Criteria**:
    - Given an animation is playing, when I adjust the speed slider, then the animation should play faster or slower accordingly.
    - Given the speed is adjusted, when I look at the speed indicator, then it should display the current frames per second.
  - **Dependencies**: Animation Playback Controls

- [x] **Frame Stepping** (Priority: Medium 3)

  - As a game artist, I want to step through animation frames one by one, so that I can examine individual frames in detail.
  - **Acceptance Criteria**:
    - Given an animation sequence is loaded, when I click the "next frame" button, then the preview should advance to the next frame in the sequence.
    - Given an animation sequence is loaded, when I click the "previous frame" button, then the preview should move to the previous frame in the sequence.
  - **Dependencies**: Animation Sequence Detection

- [x] **Frame Counter Display** (Priority: Low 4)
  - As a game artist, I want to see the current frame number and total frames, so that I can track my position in the animation.
  - **Acceptance Criteria**:
    - Given an animation sequence is loaded, when I view or play the animation, then the UI should display "Frame X of Y" where X is the current frame and Y is the total number of frames.
  - **Dependencies**: Animation Sequence Detection

## Epic 7: Image Metadata (F8)

- [ ] **Dimension Display** (Priority: High 2)

  - As a game developer, I want to see image dimensions, so that I can ensure sprites are properly sized.
  - **Acceptance Criteria**:
    - Given a sprite is selected, when I look at the metadata panel, then I should see the width × height in pixels.
  - **Dependencies**: Selection Highlighting

- [ ] **File Size Display** (Priority: Medium 3)

  - As a team lead, I want to see file sizes in appropriate units, so that I can monitor asset optimization.
  - **Acceptance Criteria**:
    - Given a sprite is selected, when I look at the metadata panel, then I should see the file size in KB or MB as appropriate.
  - **Dependencies**: Selection Highlighting

- [ ] **Format Information** (Priority: Medium 3)

  - As a game developer, I want to see image format and color depth, so that I can ensure assets meet technical requirements.
  - **Acceptance Criteria**:
    - Given a sprite is selected, when I look at the metadata panel, then I should see the image format (PNG, JPEG, etc.) and color depth information.
  - **Dependencies**: Selection Highlighting

- [ ] **Date Information** (Priority: Low 4)

  - As a team lead, I want to see creation and modification dates, so that I can track asset versioning.
  - **Acceptance Criteria**:
    - Given a sprite is selected, when I look at the metadata panel, then I should see the creation and last modified dates.
  - **Dependencies**: Selection Highlighting

- [ ] **Collapsible Metadata Panel** (Priority: Low 4)
  - As a game developer, I want the metadata panel to be collapsible, so that I can maximize the preview area when needed.
  - **Acceptance Criteria**:
    - Given the metadata panel is visible, when I click the collapse button, then the panel should hide and the preview area should expand.
    - Given the metadata panel is collapsed, when I click the expand button, then the panel should become visible again.
  - **Dependencies**: Dimension Display, File Size Display

## Epic 8: Thumbnail Generation (F9)

- [ ] **Thumbnail Creation** (Priority: High 2)

  - As a game developer, I want the application to generate thumbnails for assets, so that I can quickly identify sprites visually.
  - **Acceptance Criteria**:
    - Given a folder with sprite assets is opened, when the assets load, then thumbnails should be displayed for each asset.
  - **Dependencies**: Folder Content Display

- [ ] **Thumbnail Caching** (Priority: Medium 3)

  - As a game developer, I want thumbnails to be cached, so that folders load faster on subsequent visits.
  - **Acceptance Criteria**:
    - Given I have previously visited a folder, when I revisit that folder, then thumbnails should load noticeably faster than the first visit.
  - **Dependencies**: Thumbnail Creation

- [ ] **Background Generation** (Priority: Medium 3)

  - As a game developer, I want thumbnails to be generated in background threads, so that the UI remains responsive during folder browsing.
  - **Acceptance Criteria**:
    - Given I open a folder with many assets, when thumbnails are being generated, then I should still be able to interact with the UI without freezing or lag.
  - **Dependencies**: Thumbnail Creation

- [ ] **Thumbnail Size Preference** (Priority: Low 4)
  - As a game developer, I want to adjust thumbnail size, so that I can balance between visual detail and number of visible assets.
  - **Acceptance Criteria**:
    - Given assets are displayed with thumbnails, when I adjust the thumbnail size slider, then all thumbnails should resize accordingly.
  - **Dependencies**: Thumbnail Creation

## Epic 9: Recent Folders (F10)

- [ ] **Recent Folder Tracking** (Priority: Medium 3)

  - As a game developer, I want the application to track recently visited folders, so that I can quickly return to them.
  - **Acceptance Criteria**:
    - Given I have visited multiple folders, when I check the recent folders list, then I should see the folders I visited in reverse chronological order.
  - **Dependencies**: Folder Tree Display

- [ ] **Recent Folder Access** (Priority: Medium 3)

  - As a game developer, I want to access recent folders with a single click, so that I can quickly switch between projects.
  - **Acceptance Criteria**:
    - Given I have recent folders, when I click on a folder in the recent folders list, then the application should immediately navigate to that folder.
  - **Dependencies**: Recent Folder Tracking

- [ ] **Recent Folder Management** (Priority: Low 4)
  - As a game developer, I want to clear or remove items from my recent folders list, so that I can keep it organized.
  - **Acceptance Criteria**:
    - Given I have items in my recent folders list, when I click the "remove" button next to an item, then it should be removed from the list.
    - Given I have items in my recent folders list, when I click "clear all", then the entire list should be emptied.
  - **Dependencies**: Recent Folder Tracking

## Epic 10: UI Themes (F11)

- [ ] **Dark Theme Implementation** (Priority: Medium 3)

  - As a game developer, I want a dark theme option, so that I can reduce eye strain during extended use.
  - **Acceptance Criteria**:
    - Given I am using the application, when I select the dark theme option, then the UI should switch to a dark color scheme with proper contrast.
  - **Dependencies**: None

- [ ] **Light Theme Implementation** (Priority: Medium 3)

  - As a game developer, I want a light theme option, so that I can work in well-lit environments.
  - **Acceptance Criteria**:
    - Given I am using the application with dark theme, when I select the light theme option, then the UI should switch to a light color scheme.
  - **Dependencies**: None

- [ ] **Theme Persistence** (Priority: Low 4)
  - As a game developer, I want my theme preference to be remembered, so that I don't have to reset it each time I open the application.
  - **Acceptance Criteria**:
    - Given I have selected a theme, when I close and reopen the application, then the same theme should be applied.
  - **Dependencies**: Dark Theme Implementation, Light Theme Implementation

## Definition of Done

For all user stories, a story is considered "Done" when all following criteria are met:

- [ ] Code is complete and implements all acceptance criteria
- [ ] Code has been reviewed by at least one other developer
- [ ] Unit tests are written and passing
- [ ] All regression tests are passing
- [ ] Documentation is updated
- [ ] Accessibility standards are met
- [ ] Performance meets requirements
- [ ] No regressions in existing functionality
- [ ] Product Manager has reviewed and approved

## Release Roadmap

### Release 1: Core Viewing Functionality (Week 8)

- All Critical (1) and High (2) priority stories from Epics 1-5

### Release 2: Enhanced User Experience (Week 12)

- All High (2) priority stories from Epics 7-10
- Remaining Medium (3) priority stories from Release 1 epics

### Release 3: Advanced Capabilities (Week 16)

- All stories from Epic 6 (Animation Preview)
- Remaining Medium (3) priority stories from Release 2 epics

### Release 4: Premium Features (Week 20)

- All remaining Low (4) priority stories
- Additional premium features not detailed in this breakdown
</file>

<file path="src/renderer/src/App.tsx">
import { useState } from 'react'
import FileTreeSidebar from '../components/FileTreeSidebar'
import AssetPreview from '../components/AssetPreview'
import AssetGrid from '../components/AssetGrid'
import { SidebarProvider, SidebarTrigger } from './components/ui/sidebar'

function App(): React.JSX.Element {
  const [selectedAssetPath, setSelectedAssetPath] = useState<string | undefined>(undefined)
  const [currentFolderPath, setCurrentFolderPath] = useState<string | undefined>(undefined)
  const [activeFolderName, setActiveFolderName] = useState<string | undefined>(undefined)

  // Function to handle asset selection
  const handleAssetSelect = (assetPath: string): void => {
    console.log('Asset selected:', assetPath)
    // Add the asset:// protocol to the path
    setSelectedAssetPath(`asset://${assetPath}`)
  }

  // Function to handle folder selection
  const handleFolderSelect = (folderPath: string): void => {
    console.log('Folder selected:', folderPath)
    setCurrentFolderPath(folderPath)

    // Extract the folder name from the path for display purposes
    const folderName = folderPath.split(/[/\\]/).pop()
    setActiveFolderName(folderName)
  }

  return (
    <SidebarProvider>
      <div className="flex h-screen w-full bg-background text-foreground">
        {/* File tree sidebar */}
        <FileTreeSidebar onAssetSelect={handleAssetSelect} onFolderSelect={handleFolderSelect} />

        {/* Main content area */}
        <main className="flex-1 flex flex-col h-screen p-4">
          {/* Sidebar Trigger */}
          <div className="mb-2 flex-none">
            <SidebarTrigger className="ml-2" />
          </div>

          {/* Asset grid - takes 60% of the available space */}
          <div className="flex-1 overflow-hidden border border-border rounded-md min-h-[100px]">
            <div className="p-2 border-b border-border flex items-center">
              <h2 className="text-lg font-semibold">{activeFolderName || 'No folder selected'}</h2>
            </div>
            <div className="h-[calc(100%-40px)] overflow-auto flex">
              <AssetGrid folderPath={currentFolderPath} onAssetSelect={handleAssetSelect} />
            </div>
          </div>

          {/* Asset preview area - takes 40% of the available space */}
          <div className="flex-1 mt-4 overflow-hidden border border-border rounded-md min-h-[100px]">
            <AssetPreview assetPath={selectedAssetPath} folderPath={currentFolderPath} />
          </div>
        </main>
      </div>
    </SidebarProvider>
  )
}

export default App
</file>

<file path="src/renderer/components/FileTreeSidebar.tsx">
import React, { useState } from 'react'
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger
} from '../src/components/ui/collapsible'
import { Alert, AlertDescription } from '../src/components/ui/alert'
import {
  Sidebar,
  SidebarContent,
  SidebarHeader,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel
} from '../src/components/ui/sidebar'
import { ScrollArea } from '../src/components/ui/scroll-area'
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger
} from '../src/components/ui/tooltip'
import { cn } from '../src/lib/utils'
import {
  ChevronRight,
  Folder as FolderIcon,
  FileText as FileIcon,
  FolderKanban,
  AlertCircle
} from 'lucide-react'
import FolderPicker from './FilePicker'

interface TreeNode {
  id: string
  name: string
  type: 'folder' | 'file'
  children?: TreeNode[]
  isAssetFolder?: boolean
  path?: string
}

interface TreeItemProps {
  node: TreeNode
  level?: number
  onAssetSelect?: (assetPath: string) => void
  onFolderSelect?: (folderPath: string) => void
}

const TreeItem: React.FC<TreeItemProps> = ({ node, level = 0, onAssetSelect, onFolderSelect }) => {
  const hasChildren = node.children && node.children.length > 0
  const isFolder = node.type === 'folder'
  const indentPadding = level * 20 // 20px per level
  const [isOpen, setIsOpen] = useState(false)

  // Determine which folder icon to use
  const CurrentFolderIcon = node.isAssetFolder ? FolderKanban : FolderIcon

  // Handle folder selection
  const handleFolderClick = (e: React.MouseEvent): void => {
    if (isFolder && node.path && onFolderSelect) {
      // Stop propagation to prevent the collapsible trigger from also handling this
      e.stopPropagation()
      onFolderSelect(node.path)
    }
  }

  // Render folder item with children
  if (isFolder && hasChildren) {
    return (
      <Collapsible
        open={isOpen}
        onOpenChange={(open) => {
          console.log('Collapsible state changed:', open)
          setIsOpen(open)
        }}
        className="w-full"
      >
        <CollapsibleTrigger asChild>
          <div
            style={{ paddingLeft: `${indentPadding}px` }}
            className={cn(
              'flex items-center h-8 w-full text-sm rounded-md cursor-pointer',
              'hover:bg-muted/50 transition-colors'
            )}
          >
            <ChevronRight
              className={cn(
                'h-4 w-4 mr-1.5 transition-transform duration-200',
                isOpen && 'rotate-90'
              )}
            />
            <div onClick={handleFolderClick} className="flex items-center flex-1 overflow-hidden">
              <CurrentFolderIcon className="h-4 w-4 mr-2 flex-shrink-0 text-blue-500" />

              <Tooltip>
                <TooltipTrigger asChild>
                  <span className="truncate">
                    {' '}
                    {node.name.length > 20 ? node.name.slice(0, 20) + '...' : node.name}
                  </span>
                </TooltipTrigger>
                <TooltipContent side="right">{node.name}</TooltipContent>
              </Tooltip>
            </div>
          </div>
        </CollapsibleTrigger>
        <CollapsibleContent>
          {node.children?.map((child) => (
            <TreeItem
              key={child.id}
              node={child}
              level={level + 1}
              onAssetSelect={onAssetSelect}
              onFolderSelect={onFolderSelect}
            />
          ))}
        </CollapsibleContent>
      </Collapsible>
    )
  }

  // Empty folder
  if (isFolder) {
    return (
      <div
        style={{ paddingLeft: `${indentPadding}px` }}
        className={cn(
          'flex items-center h-8 w-full text-sm rounded-md cursor-pointer',
          'hover:bg-muted/50 transition-colors'
        )}
        onClick={handleFolderClick}
      >
        <span className="w-4 mr-1.5" /> {/* Spacer for alignment with chevron */}
        <CurrentFolderIcon className="h-4 w-4 mr-1.5 flex-shrink-0 text-blue-500" />
        <Tooltip>
          <TooltipTrigger asChild>
            <span className="truncate">{node.name}</span>
          </TooltipTrigger>
          <TooltipContent side="right">{node.name}</TooltipContent>
        </Tooltip>
      </div>
    )
  }

  // File node
  return (
    <div
      style={{ paddingLeft: `${indentPadding}px` }}
      className={cn(
        'flex items-center h-8 w-full text-sm rounded-md cursor-pointer',
        'hover:bg-muted/50 transition-colors'
      )}
      onClick={() => onAssetSelect && node.path && onAssetSelect(node.path)}
    >
      <span className="w-4 mr-1.5" /> {/* Spacer for alignment with chevron */}
      <FileIcon className="h-4 w-4 mr-1.5 flex-shrink-0 text-foreground/70" />
      <Tooltip>
        <TooltipTrigger asChild>
          <span className="truncate">{node.name}</span>
        </TooltipTrigger>
        <TooltipContent side="right">{node.name}</TooltipContent>
      </Tooltip>
    </div>
  )
}

// Import the FileTreeItem type from preload
declare interface FileTreeItem {
  id: string
  name: string
  type: 'folder' | 'file'
  path?: string
  isAssetFolder?: boolean
  children?: FileTreeItem[]
}

interface FileTreeSidebarProps {
  onAssetSelect?: (assetPath: string) => void
  onFolderSelect?: (folderPath: string) => void
}

const FileTreeSidebar: React.FC<FileTreeSidebarProps> = ({
  onAssetSelect,
  onFolderSelect
}): React.ReactElement => {
  const [fileTree, setFileTree] = useState<TreeNode[]>([])
  const [errorMessage, setErrorMessage] = useState<string | null>(null)

  // Handle folder selection from the FolderPicker component
  const handleFolderSelect = async (folderPath: string): Promise<void> => {
    try {
      const result = await window.api.navigateToFolder(folderPath)
      console.log('Navigation result:', result)

      if (result.success && result.folderPath) {
        console.log('Successfully navigated to:', result.folderPath)

        // Recursive function to map API response to TreeNode structure
        const mapToTreeNode = (item: FileTreeItem): TreeNode => {
          return {
            id: item.id,
            name: item.name,
            type: item.type,
            isAssetFolder: item.type === 'folder' ? true : undefined,
            children: item.children?.map(mapToTreeNode) || undefined,
            path: item.path
          }
        }

        // Create a proper folder structure to add to the tree
        const newNode: TreeNode = {
          id: `folder-${Date.now()}`,
          name: result.folderName || folderPath.split(/[/\\]/).pop() || 'Selected Folder',
          type: 'folder',
          isAssetFolder: true,
          children: result.children?.map(mapToTreeNode) || [],
          path: result.folderPath
        }

        // Log the node we're adding to help debug
        console.log('Adding new folder node to tree:', newNode)

        // Update the file tree with the new node
        setFileTree((prevTree) => [...prevTree, newNode])

        // Notify parent component about folder selection
        if (onFolderSelect) {
          onFolderSelect(result.folderPath)
        }
      } else {
        console.error('Failed to navigate to folder:', result.message)
        showErrorMessage(result.message || 'Failed to navigate to folder')
      }
    } catch (error) {
      console.error('Error during folder navigation:', error)
      showErrorMessage('An unexpected error occurred')
    }
  }

  // Helper to show error message
  const showErrorMessage = (message: string): void => {
    setErrorMessage(message)
    setTimeout(() => setErrorMessage(null), 5000)
  }

  return (
    <TooltipProvider>
      <Sidebar className="min-w-[400px] border-r border-border">
        <SidebarHeader className="px-4 py-2">
          <FolderPicker onFolderSelect={handleFolderSelect} onError={showErrorMessage} />
        </SidebarHeader>

        <SidebarContent>
          <SidebarGroup>
            <SidebarGroupLabel>Asset Folders</SidebarGroupLabel>
            <SidebarGroupContent>
              <ScrollArea className="h-[calc(100vh-120px)]">
                <div className="px-1 py-2">
                  {fileTree.map((node) => (
                    <TreeItem
                      key={node.id}
                      node={node}
                      level={0}
                      onAssetSelect={onAssetSelect}
                      onFolderSelect={onFolderSelect}
                    />
                  ))}
                </div>
              </ScrollArea>
            </SidebarGroupContent>
          </SidebarGroup>
        </SidebarContent>

        {/* Error message */}
        {errorMessage && (
          <Alert
            variant="destructive"
            className="fixed bottom-4 left-4 right-4 z-50 animate-in fade-in slide-in-from-bottom-5"
          >
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{errorMessage}</AlertDescription>
          </Alert>
        )}
      </Sidebar>
    </TooltipProvider>
  )
}

export default FileTreeSidebar
</file>

</files>
